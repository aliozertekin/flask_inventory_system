prompt PL/SQL Developer Export User Objects for user SYSTEM@FREE
prompt Created by alioz on 9 Temmuz 2025 Çarşamba
set define off
spool all_queries2.log

prompt
prompt Creating sequence INVENTORY_SEQ
prompt ===============================
prompt
create sequence SYSTEM.INVENTORY_SEQ
minvalue 1
maxvalue 9999999999999999999999999999
start with 568
increment by 1
nocache;

prompt
prompt Creating sequence SHIPMENT_SEQ
prompt ==============================
prompt
create sequence SYSTEM.SHIPMENT_SEQ
minvalue 1
maxvalue 9999999999999999999999999999
start with 2029
increment by 1
nocache;

prompt
prompt Creating sequence SHIPMENTS_SEQ
prompt ===============================
prompt
create sequence SYSTEM.SHIPMENTS_SEQ
minvalue 1
maxvalue 9999999999999999999999999999
start with 2029
increment by 1
nocache;

prompt
prompt Creating sequence STORE_SEQ
prompt ===========================
prompt
create sequence SYSTEM.STORE_SEQ
minvalue 1
maxvalue 9999999999999999999999999999
start with 31
increment by 1
nocache;

prompt
prompt Creating table AUDIT_LOG
prompt ========================
prompt
create table SYSTEM.AUDIT_LOG
(
  log_id     NUMBER generated by default on null as identity,
  table_name VARCHAR2(100),
  operation  VARCHAR2(10),
  changed_by VARCHAR2(100),
  changed_at TIMESTAMP(6) default CURRENT_TIMESTAMP,
  old_data   CLOB,
  new_data   CLOB
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.AUDIT_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CUSTOMER_LOG
prompt ===========================
prompt
create table SYSTEM.CUSTOMER_LOG
(
  log_id        NUMBER generated always as identity,
  customer_id   NUMBER,
  customer_name VARCHAR2(255 CHAR),
  email_address VARCHAR2(255 CHAR),
  operation     VARCHAR2(10 CHAR),
  old_data      CLOB,
  new_data      CLOB,
  changed_by    VARCHAR2(100 CHAR),
  changed_at    TIMESTAMP(6) default CURRENT_TIMESTAMP
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.CUSTOMER_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CUSTOMERS
prompt ========================
prompt
create table SYSTEM.CUSTOMERS
(
  customer_id   INTEGER generated by default on null as identity (start with 393),
  email_address VARCHAR2(255 CHAR) not null,
  full_name     VARCHAR2(255 CHAR) not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.CUSTOMERS
  is 'dimension table';
comment on column SYSTEM.CUSTOMERS.customer_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.CUSTOMERS.email_address
  is 'The email address the person uses to access the account';
comment on column SYSTEM.CUSTOMERS.full_name
  is 'What this customer is called';
create index SYSTEM.CUSTOMERS_NAME_I on SYSTEM.CUSTOMERS (FULL_NAME)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.CUSTOMERS
  add constraint CUSTOMERS_PK primary key (CUSTOMER_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  )
  novalidate;
alter table SYSTEM.CUSTOMERS
  add constraint CUSTOMERS_EMAIL_U unique (EMAIL_ADDRESS)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DR$SUP_TEXT_IDX$B
prompt ================================
prompt
create table SYSTEM.DR$SUP_TEXT_IDX$B
(
  min_docid NUMBER,
  max_docid NUMBER,
  status    NUMBER
)
tablespace SYSTEM
  pctfree 25
  pctused 40
  initrans 128
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DR$SUP_TEXT_IDX$C
prompt ================================
prompt
create table SYSTEM.DR$SUP_TEXT_IDX$C
(
  dml_scn NUMBER,
  dml_id  NUMBER,
  dml_op  NUMBER,
  dml_rid ROWID
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DR$SUP_TEXT_IDX$I
prompt ================================
prompt
create table SYSTEM.DR$SUP_TEXT_IDX$I
(
  token_text  VARCHAR2(255) not null,
  token_type  NUMBER(10) not null,
  token_first NUMBER(10) not null,
  token_last  NUMBER(10) not null,
  token_count NUMBER(10) not null,
  token_info  BLOB
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.DR$SUP_TEXT_IDX$X on SYSTEM.DR$SUP_TEXT_IDX$I (TOKEN_TEXT, TOKEN_TYPE, TOKEN_FIRST, TOKEN_LAST, TOKEN_COUNT)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  )
  compress 2;

prompt
prompt Creating table DR$SUP_TEXT_IDX$K
prompt ================================
prompt
create table SYSTEM.DR$SUP_TEXT_IDX$K
(
  docid   NUMBER,
  textkey ROWID
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index SYSTEM.DR$SUP_TEXT_IDX$KD on SYSTEM.DR$SUP_TEXT_IDX$K (DOCID, TEXTKEY)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index SYSTEM.DR$SUP_TEXT_IDX$KR on SYSTEM.DR$SUP_TEXT_IDX$K (TEXTKEY, DOCID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DR$SUP_TEXT_IDX$N
prompt ================================
prompt
create table SYSTEM.DR$SUP_TEXT_IDX$N
(
  nlt_docid NUMBER(38) not null,
  nlt_mark  CHAR(1) not null,
  primary key (NLT_DOCID)
)
organization index;

prompt
prompt Creating table DR$SUP_TEXT_IDX$Q
prompt ================================
prompt
create table SYSTEM.DR$SUP_TEXT_IDX$Q
(
  dml_id  NUMBER,
  dml_op  NUMBER,
  dml_rid ROWID
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DR$SUP_TEXT_IDX$U
prompt ================================
prompt
create table SYSTEM.DR$SUP_TEXT_IDX$U
(
  rid ROWID not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.DR$SUP_TEXT_IDX$U
  add primary key (RID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PRODUCTS
prompt =======================
prompt
create table SYSTEM.PRODUCTS
(
  product_id         INTEGER generated by default on null as identity (start with 47),
  product_name       VARCHAR2(255 CHAR) not null,
  unit_price         NUMBER(10,2),
  product_details    BLOB,
  product_image      BLOB,
  image_mime_type    VARCHAR2(512 CHAR),
  image_filename     VARCHAR2(512 CHAR),
  image_charset      VARCHAR2(512 CHAR),
  image_last_updated DATE
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.PRODUCTS
  is 'dimension table';
comment on column SYSTEM.PRODUCTS.product_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.PRODUCTS.product_name
  is 'What a product is called';
comment on column SYSTEM.PRODUCTS.unit_price
  is 'The monetary value of one item of this product';
comment on column SYSTEM.PRODUCTS.product_details
  is 'Further details of the product stored in JSON format';
comment on column SYSTEM.PRODUCTS.product_image
  is 'A picture of the product';
comment on column SYSTEM.PRODUCTS.image_mime_type
  is 'The mime-type of the product image';
comment on column SYSTEM.PRODUCTS.image_filename
  is 'The name of the file loaded in the image column';
comment on column SYSTEM.PRODUCTS.image_charset
  is 'The character set used to encode the image';
comment on column SYSTEM.PRODUCTS.image_last_updated
  is 'The date the image was last changed';
alter table SYSTEM.PRODUCTS
  add constraint PRODUCTS_PK primary key (PRODUCT_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  )
  novalidate;
alter table SYSTEM.PRODUCTS
  add constraint PRODUCTS_JSON_C
  check ( product_details is json );

prompt
prompt Creating table STORES
prompt =====================
prompt
create table SYSTEM.STORES
(
  store_id          INTEGER generated by default on null as identity (start with 24),
  store_name        VARCHAR2(255 CHAR) not null,
  web_address       VARCHAR2(100 CHAR),
  physical_address  VARCHAR2(512 CHAR),
  latitude          NUMBER(9,6),
  longitude         NUMBER(9,6),
  logo              BLOB,
  logo_mime_type    VARCHAR2(512 CHAR),
  logo_filename     VARCHAR2(512 CHAR),
  logo_charset      VARCHAR2(512 CHAR),
  logo_last_updated DATE
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.STORES
  is 'Physical and virtual locations where people can purchase products';
comment on column SYSTEM.STORES.store_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.STORES.store_name
  is 'What the store is called';
comment on column SYSTEM.STORES.web_address
  is 'The URL of a virtual store';
comment on column SYSTEM.STORES.physical_address
  is 'The postal address of this location';
comment on column SYSTEM.STORES.latitude
  is 'The north-south position of a physical store';
comment on column SYSTEM.STORES.longitude
  is 'The east-west position of a physical store';
comment on column SYSTEM.STORES.logo
  is 'An image used by this store';
comment on column SYSTEM.STORES.logo_mime_type
  is 'The mime-type of the store logo';
comment on column SYSTEM.STORES.logo_filename
  is 'The name of the file loaded in the image column';
comment on column SYSTEM.STORES.logo_charset
  is 'The character set used to encode the image';
comment on column SYSTEM.STORES.logo_last_updated
  is 'The date the image was last changed';
alter table SYSTEM.STORES
  add constraint STORES_PK primary key (STORE_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.STORES
  add constraint STORE_NAME_U unique (STORE_NAME)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.STORES
  add constraint STORE_AT_LEAST_ONE_ADDRESS_C
  check (
    web_address IS NOT NULL or physical_address IS NOT NULL
  );

prompt
prompt Creating table INVENTORY
prompt ========================
prompt
create table SYSTEM.INVENTORY
(
  inventory_id      INTEGER generated by default on null as identity (start with 567),
  store_id          INTEGER not null,
  product_id        INTEGER not null,
  product_inventory INTEGER not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.INVENTORY
  is 'Details of the quantity of stock available for products at each location';
comment on column SYSTEM.INVENTORY.inventory_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.INVENTORY.store_id
  is 'Which location the goods are located at';
comment on column SYSTEM.INVENTORY.product_id
  is 'Which item this stock is for';
comment on column SYSTEM.INVENTORY.product_inventory
  is 'The current quantity in stock';
create index SYSTEM.INVENTORY_PRODUCT_ID_I on SYSTEM.INVENTORY (PRODUCT_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.INVENTORY
  add constraint INVENTORY_PK primary key (INVENTORY_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.INVENTORY
  add constraint INVENTORY_STORE_PRODUCT_U unique (STORE_ID, PRODUCT_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.INVENTORY
  add constraint INVENTORY_PRODUCT_ID_FK foreign key (PRODUCT_ID)
  references SYSTEM.PRODUCTS (PRODUCT_ID);
alter table SYSTEM.INVENTORY
  add constraint INVENTORY_STORE_ID_FK foreign key (STORE_ID)
  references SYSTEM.STORES (STORE_ID);

prompt
prompt Creating table INVENTORY_LOG
prompt ============================
prompt
create table SYSTEM.INVENTORY_LOG
(
  log_id        NUMBER generated always as identity,
  inventory_id  NUMBER,
  store_id      NUMBER,
  product_id    NUMBER,
  change_amount NUMBER,
  old_quantity  NUMBER,
  new_quantity  NUMBER,
  operation     VARCHAR2(10 CHAR),
  changed_by    VARCHAR2(100 CHAR),
  changed_at    TIMESTAMP(6) default CURRENT_TIMESTAMP
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.INVENTORY_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ORDERS
prompt =====================
prompt
create table SYSTEM.ORDERS
(
  order_id     INTEGER generated by default on null as identity (start with 1951),
  order_tms    TIMESTAMP(6) not null,
  customer_id  INTEGER not null,
  order_status VARCHAR2(10 CHAR) not null,
  store_id     INTEGER not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.ORDERS
  is 'Details of who made purchases where';
comment on column SYSTEM.ORDERS.order_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.ORDERS.order_tms
  is 'When the order was placed';
comment on column SYSTEM.ORDERS.customer_id
  is 'Who placed this order';
comment on column SYSTEM.ORDERS.order_status
  is 'What state the order is in. Valid values are:
OPEN - the order is in progress
PAID - money has been received from the customer for this order
SHIPPED - the products have been dispatched to the customer
COMPLETE - the customer has received the order
CANCELLED - the customer has stopped the order
REFUNDED - there has been an issue with the order and the money has been returned to the customer';
comment on column SYSTEM.ORDERS.store_id
  is 'Where this order was placed';
create index SYSTEM.IDX_ORDERS_ORDER_TMS on SYSTEM.ORDERS (ORDER_TMS)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.ORDERS_CUSTOMER_ID_I on SYSTEM.ORDERS (CUSTOMER_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.ORDERS_STORE_ID_I on SYSTEM.ORDERS (STORE_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDERS
  add constraint ORDERS_PK primary key (ORDER_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDERS
  add constraint ORDERS_CUSTOMER_ID_FK foreign key (CUSTOMER_ID)
  references SYSTEM.CUSTOMERS (CUSTOMER_ID);
alter table SYSTEM.ORDERS
  add constraint ORDERS_STORE_ID_FK foreign key (STORE_ID)
  references SYSTEM.STORES (STORE_ID);
alter table SYSTEM.ORDERS
  add constraint ORDERS_STATUS_C
  check ( order_status in
                    ( 'CANCELLED','COMPLETE','OPEN','PAID','REFUNDED','SHIPPED'));

prompt
prompt Creating table SHIPMENTS
prompt ========================
prompt
create table SYSTEM.SHIPMENTS
(
  shipment_id      INTEGER generated by default on null as identity (start with 2027),
  store_id         INTEGER not null,
  customer_id      INTEGER not null,
  delivery_address VARCHAR2(512 CHAR) not null,
  shipment_status  VARCHAR2(100 CHAR) not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.SHIPMENTS
  is 'Details of where ordered goods will be delivered';
comment on column SYSTEM.SHIPMENTS.shipment_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.SHIPMENTS.store_id
  is 'Which location the goods will be transported from';
comment on column SYSTEM.SHIPMENTS.customer_id
  is 'Who this shipment is for';
comment on column SYSTEM.SHIPMENTS.delivery_address
  is 'Where the goods will be transported to';
comment on column SYSTEM.SHIPMENTS.shipment_status
  is 'The current status of the shipment. Valid values are:
CREATED - the shipment is ready for order assignment
SHIPPED - the goods have been dispatched
IN-TRANSIT - the goods are en-route to their destination
DELIVERED - the good have arrived at their destination';
create index SYSTEM.SHIPMENTS_CUSTOMER_ID_I on SYSTEM.SHIPMENTS (CUSTOMER_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.SHIPMENTS_STORE_ID_I on SYSTEM.SHIPMENTS (STORE_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.SHIPMENTS
  add constraint SHIPMENTS_PK primary key (SHIPMENT_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.SHIPMENTS
  add constraint SHIPMENTS_CUSTOMER_ID_FK foreign key (CUSTOMER_ID)
  references SYSTEM.CUSTOMERS (CUSTOMER_ID);
alter table SYSTEM.SHIPMENTS
  add constraint SHIPMENTS_STORE_ID_FK foreign key (STORE_ID)
  references SYSTEM.STORES (STORE_ID);
alter table SYSTEM.SHIPMENTS
  add constraint SHIPMENT_STATUS_C
  check ( shipment_status in
                    ( 'CREATED', 'SHIPPED', 'IN-TRANSIT', 'DELIVERED'));

prompt
prompt Creating table ORDER_ITEMS
prompt ==========================
prompt
create table SYSTEM.ORDER_ITEMS
(
  order_id         INTEGER not null,
  line_item_id     INTEGER not null,
  product_id       INTEGER not null,
  unit_price       NUMBER(10,2) not null,
  quantity         INTEGER not null,
  shipment_id      INTEGER,
  delivery_address VARCHAR2(255)
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.ORDER_ITEMS
  is 'Details of which products the customer has purchased in an order';
comment on column SYSTEM.ORDER_ITEMS.order_id
  is 'The order these products belong to';
comment on column SYSTEM.ORDER_ITEMS.line_item_id
  is 'An incrementing number, starting at one for each order';
comment on column SYSTEM.ORDER_ITEMS.product_id
  is 'Which item was purchased';
comment on column SYSTEM.ORDER_ITEMS.unit_price
  is 'How much the customer paid for one item of the product';
comment on column SYSTEM.ORDER_ITEMS.quantity
  is 'How many items of this product the customer purchased';
comment on column SYSTEM.ORDER_ITEMS.shipment_id
  is 'Where this product will be delivered';
create index SYSTEM.IDX_ORDER_ITEMS_ORDER_ID on SYSTEM.ORDER_ITEMS (ORDER_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.ORDER_ITEMS_SHIPMENT_ID_I on SYSTEM.ORDER_ITEMS (SHIPMENT_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_PK primary key (ORDER_ID, LINE_ITEM_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_PRODUCT_U unique (PRODUCT_ID, ORDER_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_ORDER_ID_FK foreign key (ORDER_ID)
  references SYSTEM.ORDERS (ORDER_ID);
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_PRODUCT_ID_FK foreign key (PRODUCT_ID)
  references SYSTEM.PRODUCTS (PRODUCT_ID);
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_SHIPMENT_ID_FK foreign key (SHIPMENT_ID)
  references SYSTEM.SHIPMENTS (SHIPMENT_ID);

prompt
prompt Creating table ORDER_ITEMS_LOG
prompt ==============================
prompt
create table SYSTEM.ORDER_ITEMS_LOG
(
  log_id      NUMBER generated by default on null as identity,
  order_id    NUMBER,
  order_tms   TIMESTAMP(6),
  customer_id NUMBER,
  store_id    NUMBER,
  operation   VARCHAR2(10),
  old_data    CLOB,
  new_data    CLOB,
  changed_by  VARCHAR2(50),
  changed_at  TIMESTAMP(6) default SYSTIMESTAMP
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDER_ITEMS_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ORDER_LOG
prompt ========================
prompt
create table SYSTEM.ORDER_LOG
(
  log_id      NUMBER generated always as identity,
  order_id    NUMBER,
  order_tms   TIMESTAMP(6),
  customer_id NUMBER,
  store_id    NUMBER,
  operation   VARCHAR2(10 CHAR),
  old_data    CLOB,
  new_data    CLOB,
  changed_by  VARCHAR2(100 CHAR),
  changed_at  TIMESTAMP(6) default CURRENT_TIMESTAMP
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDER_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PRODUCT_LOG
prompt ==========================
prompt
create table SYSTEM.PRODUCT_LOG
(
  log_id       NUMBER generated always as identity,
  product_id   NUMBER,
  product_name VARCHAR2(255 CHAR),
  unit_price   NUMBER(10,2),
  operation    VARCHAR2(10 CHAR),
  old_data     CLOB,
  new_data     CLOB,
  changed_by   VARCHAR2(100 CHAR),
  changed_at   TIMESTAMP(6) default CURRENT_TIMESTAMP
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.PRODUCT_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHIPMENTS_LOG
prompt ============================
prompt
create table SYSTEM.SHIPMENTS_LOG
(
  log_id      NUMBER generated always as identity,
  shipment_id NUMBER,
  operation   VARCHAR2(10),
  old_data    CLOB,
  new_data    CLOB,
  changed_by  VARCHAR2(100),
  changed_at  TIMESTAMP(6) default CURRENT_TIMESTAMP
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.SHIPMENTS_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table STORE_LOG
prompt ========================
prompt
create table SYSTEM.STORE_LOG
(
  log_id           NUMBER generated always as identity,
  store_id         NUMBER,
  store_name       VARCHAR2(255 CHAR),
  physical_address VARCHAR2(512 CHAR),
  operation        VARCHAR2(10 CHAR),
  old_data         CLOB,
  new_data         CLOB,
  changed_by       VARCHAR2(100 CHAR),
  changed_at       TIMESTAMP(6) default CURRENT_TIMESTAMP
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.STORE_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating view CUSTOMER_ORDER_PRODUCTS
prompt =====================================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.CUSTOMER_ORDER_PRODUCTS AS
SELECT o.order_id, o.order_tms, o.order_status,
         c.customer_id, c.email_address, c.full_name,
         SUM ( oi.quantity * oi.unit_price ) order_total,
         LISTAGG (
           p.product_name, ', '
           ON OVERFLOW TRUNCATE '...' WITH COUNT
         ) WITHIN GROUP ( ORDER BY oi.line_item_id ) items
  FROM   orders o
  JOIN   order_items oi
  ON     o.order_id = oi.order_id
  JOIN   customers c
  ON     o.customer_id = c.customer_id
  JOIN   products p
  ON     oi.product_id = p.product_id
  GROUP  BY o.order_id, o.order_tms, o.order_status,
         c.customer_id, c.email_address, c.full_name;
comment on table SYSTEM.CUSTOMER_ORDER_PRODUCTS is 'A summary of who placed each order and what they bought';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ORDER_ID is 'The primary key of the order';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ORDER_TMS is 'The date and time the order was placed';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ORDER_STATUS is 'The current state of this order';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.CUSTOMER_ID is 'The primary key of the customer';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.EMAIL_ADDRESS is 'The email address the person uses to access the account';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.FULL_NAME is 'What this customer is called';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ORDER_TOTAL is 'The total amount the customer paid for the order';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ITEMS is 'A comma-separated list naming the products in this order';

prompt
prompt Creating view INVENTORY_VIEW
prompt ============================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.INVENTORY_VIEW AS
SELECT
  i.inventory_id,
  s.store_id,
  s.store_name,
  p.product_id,
  p.product_name,
  p.unit_price,
  i.product_inventory
FROM inventory i
JOIN products p ON i.product_id = p.product_id
JOIN stores s ON i.store_id = s.store_id
ORDER BY i.inventory_id ASC;

prompt
prompt Creating view ORDERS_VIEW
prompt =========================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.ORDERS_VIEW AS
SELECT
    o.order_id,
    o.order_tms,
    o.order_status,
    c.full_name AS customer_name,
    s.store_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN stores s ON o.store_id = s.store_id
ORDER BY o.order_tms DESC;

prompt
prompt Creating view PRODUCT_ORDERS
prompt ============================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.PRODUCT_ORDERS AS
SELECT p.product_name, o.order_status,
         SUM ( oi.quantity * oi.unit_price ) total_sales,
         COUNT (*) order_count
  FROM   orders o
  JOIN   order_items oi
  ON     o.order_id = oi.order_id
  JOIN   customers c
  ON     o.customer_id = c.customer_id
  JOIN   products p
  ON     oi.product_id = p.product_id
  GROUP  BY p.product_name, o.order_status;
comment on table SYSTEM.PRODUCT_ORDERS is 'A summary of the state of the orders placed for each product';
comment on column SYSTEM.PRODUCT_ORDERS.PRODUCT_NAME is 'What this product is called';
comment on column SYSTEM.PRODUCT_ORDERS.ORDER_STATUS is 'The current state of these order';
comment on column SYSTEM.PRODUCT_ORDERS.TOTAL_SALES is 'The total value of orders placed';
comment on column SYSTEM.PRODUCT_ORDERS.ORDER_COUNT is 'The total number of orders placed';

prompt
prompt Creating view PRODUCT_REVIEW_META
prompt =================================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.PRODUCT_REVIEW_META AS
SELECT
    product_id,
    product_name,
    product_details
FROM
    products;

prompt
prompt Creating view PRODUCT_REVIEWS
prompt =============================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.PRODUCT_REVIEWS AS
SELECT p.product_name, r.rating,
         ROUND (
           AVG ( r.rating ) over (
             PARTITION BY product_name
           ),
           2
         ) avg_rating,
         r.review
  FROM   products p,
         JSON_TABLE (
           p.product_details, '$'
           COLUMNS (
             NESTED PATH '$.reviews[*]'
             COLUMNS (
               rating INTEGER PATH '$.rating',
               review VARCHAR2(4000) PATH '$.review'
             )
           )
         ) r;
comment on table SYSTEM.PRODUCT_REVIEWS is 'A relational view of the reviews stored in the JSON for each product';
comment on column SYSTEM.PRODUCT_REVIEWS.PRODUCT_NAME is 'What this product is called';
comment on column SYSTEM.PRODUCT_REVIEWS.RATING is 'The review score the customer has placed. Range is 1-10';
comment on column SYSTEM.PRODUCT_REVIEWS.AVG_RATING is 'The mean of the review scores for this product';
comment on column SYSTEM.PRODUCT_REVIEWS.REVIEW is 'The text of the review';

prompt
prompt Creating view STORE_ORDERS
prompt ==========================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.STORE_ORDERS AS
SELECT CASE
           grouping_id ( store_name, order_status )
           WHEN 1 THEN 'STORE TOTAL'
           WHEN 2 THEN 'STATUS TOTAL'
           WHEN 3 THEN 'GRAND TOTAL'
         END total,
         s.store_name,
         COALESCE ( s.web_address, s.physical_address ) address,
         s.latitude, s.longitude,
         o.order_status,
         COUNT ( DISTINCT o.order_id ) order_count,
         SUM ( oi.quantity * oi.unit_price ) total_sales
  FROM   stores s
  JOIN   orders o
  ON     s.store_id = o.store_id
  JOIN   order_items oi
  ON     o.order_id = oi.order_id
  GROUP  BY GROUPING SETS (
    ( s.store_name, COALESCE ( s.web_address, s.physical_address ), s.latitude, s.longitude ),
    ( s.store_name, COALESCE ( s.web_address, s.physical_address ), s.latitude, s.longitude, o.order_status ),
    o.order_status,
    ()
  );
comment on table SYSTEM.STORE_ORDERS is 'A summary of what was purchased at each location, including summaries each store, order status and overall total';
comment on column SYSTEM.STORE_ORDERS.TOTAL is 'Indicates what type of total is displayed, including Store, Status, or Grand Totals';
comment on column SYSTEM.STORE_ORDERS.STORE_NAME is 'What the store is called';
comment on column SYSTEM.STORE_ORDERS.ADDRESS is 'The physical or virtual location of this store';
comment on column SYSTEM.STORE_ORDERS.LATITUDE is 'The north-south position of a physical store';
comment on column SYSTEM.STORE_ORDERS.LONGITUDE is 'The east-west position of a physical store';
comment on column SYSTEM.STORE_ORDERS.ORDER_STATUS is 'The current state of this order';
comment on column SYSTEM.STORE_ORDERS.ORDER_COUNT is 'The total number of orders placed';
comment on column SYSTEM.STORE_ORDERS.TOTAL_SALES is 'The total value of orders placed';

prompt
prompt Creating view VW_INVENTORY_STATS
prompt ================================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.VW_INVENTORY_STATS AS
SELECT 
    SUM(i.product_inventory) AS total_products,
    SUM(i.product_inventory * p.unit_price) AS total_value
FROM 
    inventory i
JOIN 
    products p ON i.product_id = p.product_id;

prompt
prompt Creating view VW_ORDER_STATS
prompt ============================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.VW_ORDER_STATS AS
SELECT 
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(oi.quantity * oi.unit_price) AS total_cost
FROM 
    order_items oi
JOIN 
    orders o ON oi.order_id = o.order_id 
WHERE 
    o.order_status NOT IN ('CANCELLED', 'REFUNDED');

prompt
prompt Creating view VW_USER_COUNT
prompt ===========================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.VW_USER_COUNT AS
SELECT COUNT(*) AS customer_id FROM customers;

prompt
prompt Creating materialized view MV_DAILY_STATS
prompt =========================================
prompt
CREATE MATERIALIZED VIEW SYSTEM.MV_DAILY_STATS
REFRESH COMPLETE ON DEMAND
AS
SELECT 
  TRUNC(SYSDATE) AS report_date,
  c.user_count,
  i.total_products,
  i.total_value,
  o.today_orders,
  o.today_sales
FROM 
  (SELECT COUNT(*) AS user_count FROM customers) c,
  (SELECT 
     SUM(product_inventory) AS total_products,
     SUM(product_inventory * unit_price) AS total_value
   FROM inventory i JOIN products p ON i.product_id = p.product_id) i,
  (SELECT 
     COUNT(*) AS today_orders,
     NVL(SUM(oi.quantity * oi.unit_price), 0) AS today_sales
   FROM order_items oi JOIN orders o ON oi.order_id = o.order_id
   WHERE TRUNC(o.order_tms) = TRUNC(SYSDATE)) o;

prompt
prompt Creating package DASHBOARD_PKG
prompt ==============================
prompt
CREATE OR REPLACE NONEDITIONABLE PACKAGE SYSTEM.dashboard_pkg AS
    -- Dashboard için tüm istatistikleri getiren fonksiyon
    FUNCTION get_dashboard_stats RETURN SYS_REFCURSOR;

    -- Aylık değişim verilerini getiren fonksiyon
    FUNCTION get_monthly_changes RETURN SYS_REFCURSOR;
END dashboard_pkg;
/

prompt
prompt Creating type ORDER_ITEM_REC
prompt ============================
prompt
CREATE OR REPLACE NONEDITIONABLE TYPE SYSTEM.order_item_rec AS OBJECT (
  product_id NUMBER,
  quantity NUMBER,
  unit_price NUMBER
);
/

prompt
prompt Creating type ORDER_ITEM_TABLE
prompt ==============================
prompt
CREATE OR REPLACE NONEDITIONABLE TYPE SYSTEM.order_item_table AS TABLE OF order_item_rec;
/

prompt
prompt Creating type T_STOCK_ROW
prompt =========================
prompt
CREATE OR REPLACE NONEDITIONABLE TYPE SYSTEM.t_stock_row AS OBJECT (
    inventory_id NUMBER(38,0),
    product_inventory NUMBER(38,0)
);
/

prompt
prompt Creating function GET_ORDER_TOTAL
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE FUNCTION SYSTEM.get_order_total(p_order_id IN NUMBER)
RETURN NUMBER IS
  v_total NUMBER := 0;
BEGIN
  SELECT SUM(unit_price * quantity)
  INTO v_total
  FROM order_items
  WHERE order_id = p_order_id;

  RETURN NVL(v_total, 0);
END get_order_total;
/

prompt
prompt Creating procedure ADD_CUSTOMER
prompt ===============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.add_customer (
  p_email IN VARCHAR2,
  p_name  IN VARCHAR2
) IS
BEGIN
  INSERT INTO customers (email_address, full_name)
  VALUES (p_email, p_name);
  COMMIT;
END;
/

prompt
prompt Creating procedure ADD_INVENTORY
prompt ================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.ADD_INVENTORY (
  p_store_id       IN  NUMBER,
  p_product_id     IN  NUMBER,
  p_product_amount IN  NUMBER,
  p_old_amount     OUT NUMBER,
  p_new_amount     OUT NUMBER,
  p_changed_by     IN  VARCHAR2 DEFAULT 'SYSTEM'
) IS
  v_inventory_id NUMBER;
BEGIN
  BEGIN
    SELECT inventory_id, product_inventory
    INTO v_inventory_id, p_old_amount
    FROM inventory
    WHERE store_id = p_store_id AND product_id = p_product_id
    FOR UPDATE NOWAIT;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_inventory_id := NULL;
      p_old_amount := 0;
  END;

  IF v_inventory_id IS NOT NULL THEN
    UPDATE inventory
    SET product_inventory = product_inventory + p_product_amount
    WHERE inventory_id = v_inventory_id;

    SELECT product_inventory INTO p_new_amount FROM inventory WHERE inventory_id = v_inventory_id;
  ELSE
    SELECT inventory_seq.NEXTVAL INTO v_inventory_id FROM dual;

    INSERT INTO inventory (inventory_id, store_id, product_id, product_inventory)
    VALUES (v_inventory_id, p_store_id, p_product_id, p_product_amount);

    p_new_amount := p_product_amount;
  END IF;

  INSERT INTO inventory_log (
    inventory_id, store_id, product_id,
    change_amount, old_quantity, new_quantity,
    operation, changed_at, changed_by
  ) VALUES (
    v_inventory_id, p_store_id, p_product_id,
    p_product_amount, p_old_amount, p_new_amount,
    'ADD', SYSTIMESTAMP, p_changed_by
  );

  COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END ADD_INVENTORY;
/

prompt
prompt Creating procedure ADD_ORDER
prompt ============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.add_order (
  p_customer_id      IN NUMBER,
  p_store_id         IN NUMBER,
  p_order_items      IN order_item_table,
  p_delivery_address IN VARCHAR2,
  p_order_id         OUT NUMBER
) AS
  v_line_item_id NUMBER := 1;
  v_shipment_id  NUMBER;
BEGIN
  -- Siparişi oluştur
  INSERT INTO orders(order_tms, customer_id, order_status, store_id)
  VALUES (SYSTIMESTAMP, p_customer_id, 'OPEN', p_store_id)
  RETURNING order_id INTO p_order_id;

  -- Kargoyu oluştur
  INSERT INTO shipments(store_id, customer_id, delivery_address, shipment_status)
  VALUES (p_store_id, p_customer_id, p_delivery_address, 'CREATED')
  RETURNING shipment_id INTO v_shipment_id;

  -- Sipariş kalemlerini ekle
  FOR i IN 1 .. p_order_items.COUNT LOOP
    DECLARE
      v_quantity_needed NUMBER := p_order_items(i).quantity;
      v_stock_accum     NUMBER := 0;
      v_idx             PLS_INTEGER := 1;

      CURSOR c_inv IS
        SELECT inventory_id, product_inventory
        FROM inventory
        WHERE store_id = p_store_id AND product_id = p_order_items(i).product_id
        ORDER BY inventory_id
        FOR UPDATE;

      TYPE inv_tab_type IS TABLE OF c_inv%ROWTYPE INDEX BY PLS_INTEGER;
      v_inv_tab inv_tab_type;
    BEGIN
      -- Stoğu oku
      OPEN c_inv;
      FETCH c_inv BULK COLLECT INTO v_inv_tab;
      CLOSE c_inv;

      FOR idx IN 1 .. v_inv_tab.COUNT LOOP
        v_stock_accum := v_stock_accum + v_inv_tab(idx).product_inventory;
      END LOOP;

      IF v_stock_accum < v_quantity_needed THEN
        RAISE_APPLICATION_ERROR(-20001, 'Yeterli stok yok: Ürün ' || p_order_items(i).product_id);
      END IF;

      -- Stok azalt
      WHILE v_quantity_needed > 0 AND v_idx <= v_inv_tab.COUNT LOOP
        IF v_inv_tab(v_idx).product_inventory <= v_quantity_needed THEN
          UPDATE inventory
          SET product_inventory = 0
          WHERE inventory_id = v_inv_tab(v_idx).inventory_id;
          v_quantity_needed := v_quantity_needed - v_inv_tab(v_idx).product_inventory;
        ELSE
          UPDATE inventory
          SET product_inventory = product_inventory - v_quantity_needed
          WHERE inventory_id = v_inv_tab(v_idx).inventory_id;
          v_quantity_needed := 0;
        END IF;
        v_idx := v_idx + 1;
      END LOOP;

      -- Sipariş kalemini ekle, shipment_id'yi ata
      INSERT INTO order_items(order_id, line_item_id, product_id, unit_price, quantity, shipment_id)
      VALUES (p_order_id, v_line_item_id, p_order_items(i).product_id,
              p_order_items(i).unit_price, p_order_items(i).quantity, v_shipment_id);

      v_line_item_id := v_line_item_id + 1;
    END;
  END LOOP;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/

prompt
prompt Creating procedure ADD_PRODUCT
prompt ==============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.ADD_PRODUCT(
  p_product_name     IN VARCHAR2,
  p_unit_price       IN NUMBER,
  p_product_details  IN BLOB DEFAULT NULL,
  p_product_image    IN BLOB DEFAULT NULL,
  p_image_mime_type  IN VARCHAR2 DEFAULT NULL,
  p_image_filename   IN VARCHAR2 DEFAULT NULL,
  p_image_charset    IN VARCHAR2 DEFAULT NULL
)
IS
BEGIN
  INSERT INTO products (
    product_name,
    unit_price,
    product_details,
    product_image,
    image_mime_type,
    image_filename,
    image_charset,
    image_last_updated
  )
  VALUES (
    p_product_name,
    p_unit_price,
    p_product_details,
    p_product_image,
    p_image_mime_type,
    p_image_filename,
    p_image_charset,
    SYSDATE
  );

  COMMIT;
END;
/

prompt
prompt Creating procedure ADD_REVIEW
prompt =============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.add_review (
    p_product_id IN NUMBER,
    p_customer_id IN NUMBER,
    p_rating IN NUMBER,
    p_review_text IN VARCHAR2
) AS
    l_blob           BLOB;
    l_clob           CLOB;
    l_details_json   JSON_OBJECT_T;
    l_reviews        JSON_ARRAY_T;
    l_new_review     JSON_OBJECT_T;
    l_dest_offset    INTEGER := 1;
    l_src_offset     INTEGER := 1;
    l_lang_ctx       INTEGER := DBMS_LOB.DEFAULT_LANG_CTX;
    l_warning        INTEGER;
BEGIN
    -- 1. Ürünün BLOB içeriğini oku
    SELECT product_details INTO l_blob
    FROM products
    WHERE product_id = p_product_id
    FOR UPDATE;

    -- 2. BLOB → geçici CLOB’a dönüştür
    DBMS_LOB.CREATETEMPORARY(l_clob, TRUE);
    DBMS_LOB.CONVERTTOCLOB(
        dest_lob     => l_clob,
        src_blob     => l_blob,
        amount       => DBMS_LOB.LOBMAXSIZE,
        dest_offset  => l_dest_offset,
        src_offset   => l_src_offset,
        blob_csid    => DBMS_LOB.DEFAULT_CSID,
        lang_context => l_lang_ctx,
        warning      => l_warning
    );

    -- 3. JSON objesine çevir
    l_details_json := JSON_OBJECT_T.parse(l_clob);

    -- 4. reviews array'ini al veya oluştur
    IF l_details_json.has('reviews') THEN
        l_reviews := l_details_json.get_array('reviews');
    ELSE
        l_reviews := JSON_ARRAY_T();
    END IF;

    -- 5. Yeni review objesi
    l_new_review := JSON_OBJECT_T();
    l_new_review.put('rating', p_rating);
    l_new_review.put('review', p_review_text);
    l_new_review.put('customer_id', p_customer_id);
    l_new_review.put('review_date', TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS'));

    -- 6. Listeye ekle
    l_reviews.append(l_new_review);

    -- 7. JSON objesini güncelle
    l_details_json.put('reviews', l_reviews);
    l_clob := l_details_json.to_string;

    -- 8. Güncellenmiş CLOB’u tekrar BLOB olarak güncelle
    UPDATE products
    SET product_details = UTL_RAW.CAST_TO_RAW(l_clob)
    WHERE product_id = p_product_id;

    COMMIT;
END;
/

prompt
prompt Creating procedure ADD_SHIPMENT
prompt ===============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.ADD_SHIPMENT(
  p_store_id         IN NUMBER,
  p_customer_id      IN NUMBER,
  p_delivery_address IN VARCHAR2,
  p_shipment_status  IN VARCHAR2
) IS
  v_shipment_id NUMBER;
BEGIN
  SELECT SHIPMENT_SEQ.NEXTVAL INTO v_shipment_id FROM DUAL;

  INSERT INTO shipments (
    shipment_id,
    store_id,
    customer_id,
    delivery_address,
    shipment_status
  ) VALUES (
    v_shipment_id,
    p_store_id,
    p_customer_id,
    p_delivery_address,
    p_shipment_status
  );

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END ADD_SHIPMENT;
/

prompt
prompt Creating procedure ADD_STORE
prompt ============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.ADD_STORE(
  p_store_name       IN VARCHAR2,
  p_web_address      IN VARCHAR2,
  p_physical_address IN VARCHAR2,
  p_latitude         IN NUMBER,
  p_longitude        IN NUMBER,
  p_logo             IN BLOB DEFAULT NULL,
  p_logo_mime_type   IN VARCHAR2 DEFAULT NULL,
  p_logo_filename    IN VARCHAR2 DEFAULT NULL,
  p_logo_charset     IN VARCHAR2 DEFAULT NULL
)
IS
BEGIN
  INSERT INTO stores (
    store_id,
    store_name,
    web_address,
    physical_address,
    latitude,
    longitude,
    logo,
    logo_mime_type,
    logo_filename,
    logo_charset,
    logo_last_updated
  ) VALUES (
    store_seq.NEXTVAL,
    p_store_name,
    p_web_address,
    p_physical_address,
    p_latitude,
    p_longitude,
    p_logo,
    p_logo_mime_type,
    p_logo_filename,
    p_logo_charset,
    SYSDATE
  );

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END ADD_STORE;
/

prompt
prompt Creating procedure DELETE_CUSTOMER
prompt ==================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_CUSTOMER(p_customer_id IN NUMBER) IS
BEGIN
  -- Öncelikle müşterinin tüm siparişlerini ve order_items silmek gerekebilir

  FOR order_rec IN (SELECT order_id FROM orders WHERE customer_id = p_customer_id) LOOP
    DELETE FROM order_items WHERE order_id = order_rec.order_id;
    DELETE FROM orders WHERE order_id = order_rec.order_id;
  END LOOP;

  -- Müşteriyi sil
  DELETE FROM customers WHERE customer_id = p_customer_id;

  COMMIT;
END DELETE_CUSTOMER;
/

prompt
prompt Creating procedure DELETE_INVENTORY
prompt ===================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_INVENTORY(p_inventory_id IN NUMBER) IS
BEGIN
  DELETE FROM inventory WHERE inventory_id = p_inventory_id;
  COMMIT;
END DELETE_INVENTORY;
/

prompt
prompt Creating procedure DELETE_ORDER
prompt ===============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_ORDER(p_order_id IN NUMBER) IS
BEGIN
  -- Öncelikle ilgili order_items kayıtlarını silelim (Foreign Key varsa)
  DELETE FROM order_items WHERE order_id = p_order_id;
  
  -- Ardından orders tablosundan siparişi silelim
  DELETE FROM orders WHERE order_id = p_order_id;
  
  COMMIT;
END DELETE_ORDER;
/

prompt
prompt Creating procedure DELETE_PRODUCT
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_PRODUCT(p_product_id IN INTEGER) IS
BEGIN
  DELETE FROM products
  WHERE product_id = p_product_id;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END DELETE_PRODUCT;
/

prompt
prompt Creating procedure DELETE_PRODUCT_IMAGE
prompt =======================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_PRODUCT_IMAGE(p_product_id IN NUMBER) AS
  v_image_exists NUMBER := 0;
BEGIN
  -- Önce gerçekten resim var mı kontrol et
  SELECT COUNT(*) INTO v_image_exists
  FROM products
  WHERE product_id = p_product_id AND product_image IS NOT NULL;

  IF v_image_exists = 1 THEN
    UPDATE products
    SET product_image = NULL,
        image_mime_type = NULL,
        image_filename = NULL,
        image_charset = NULL,
        image_last_updated = SYSDATE
    WHERE product_id = p_product_id;

    COMMIT;
  END IF;
END;
/

prompt
prompt Creating procedure DELETE_SHIPMENT
prompt ==================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_SHIPMENT(
  p_shipment_id IN NUMBER
) IS
BEGIN
  DELETE FROM shipments
  WHERE shipment_id = p_shipment_id;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END DELETE_SHIPMENT;
/

prompt
prompt Creating procedure DELETE_STORE
prompt ===============================
prompt
create or replace noneditionable procedure system.delete_store(p_store_id IN INTEGER) is
begin

  DELETE FROM stores
  WHERE store_id = p_store_id;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END DELETE_store;
/

prompt
prompt Creating procedure PRINT_ORDER_TOTAL
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.print_order_total(p_order_id IN NUMBER) IS
  v_total NUMBER := 0;
BEGIN
  SELECT SUM(unit_price * quantity)
  INTO v_total
  FROM order_items
  WHERE order_id = p_order_id;

  DBMS_OUTPUT.PUT_LINE('Total: ' || NVL(v_total, 0));
END;
/

prompt
prompt Creating procedure RESTOCK_ORDER_PRODUCTS
prompt =========================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.restock_order_products(
  p_order_id IN NUMBER,
  p_store_id IN NUMBER
)
IS
BEGIN
  FOR rec IN (
    SELECT product_id, SUM(quantity) AS total_quantity
    FROM order_items
    WHERE order_id = p_order_id
    GROUP BY product_id
  ) LOOP
    UPDATE inventory
    SET product_inventory = product_inventory + rec.total_quantity
    WHERE product_id = rec.product_id
      AND store_id = p_store_id;
  END LOOP;
END;
/

prompt
prompt Creating package body DASHBOARD_PKG
prompt ===================================
prompt
CREATE OR REPLACE NONEDITIONABLE PACKAGE BODY SYSTEM.dashboard_pkg AS
    FUNCTION get_dashboard_stats RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
        WITH stats AS (
            SELECT 
                (SELECT COUNT(*) FROM stores) AS store_count,
                (SELECT COUNT(*) FROM products) AS product_count,
                (SELECT COUNT(*) FROM customers) AS customer_count,
                (SELECT COUNT(*) FROM orders) AS order_count,
                (SELECT COUNT(*) FROM shipments) AS shipment_count,
                (SELECT SUM(p.unit_price * i.product_inventory) 
                 FROM products p 
                 JOIN inventory i ON p.product_id = i.product_id) AS inventory_value,
                (SELECT SUM(oi.quantity * oi.unit_price) 
                 FROM order_items oi) AS total_sales,
                (SELECT COUNT(*) 
                 FROM inventory i 
                 WHERE i.product_inventory < 10) AS low_stock_items,
                -- Complex metrics
                (SELECT AVG(oi.quantity * oi.unit_price) 
                 FROM order_items oi) AS avg_order_value,
                (SELECT SUM(oi.quantity * oi.unit_price) / COUNT(DISTINCT o.customer_id)
                 FROM order_items oi
                 JOIN orders o ON oi.order_id = o.order_id) AS avg_customer_spending,
                (SELECT MAX(oi.quantity * oi.unit_price) 
                 FROM order_items oi) AS max_order_value,
                (SELECT SUM(product_inventory) 
                 FROM inventory i 
                 )AS total_stock,
                (SELECT COUNT(DISTINCT o.customer_id) 
                 FROM orders o 
                 WHERE o.order_tms >= ADD_MONTHS(SYSDATE, -1)) AS active_customers,
                (SELECT COUNT(*) 
                 FROM shipments 
                 WHERE shipment_status = 'DELIVERED') AS delivered_shipments,
                (SELECT COUNT(*) 
                 FROM shipments 
                 WHERE shipment_status = 'IN-TRANSIT') AS in_transit_shipments,
                (SELECT COUNT(*) 
                 FROM shipments 
                 WHERE shipment_status = 'SHIPPED') AS preparing_shipments
            FROM dual
        )
        SELECT * FROM stats;

        RETURN v_cursor;
    END;

    FUNCTION get_monthly_changes RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
        WITH monthly_data AS (
            SELECT 
                TRUNC(o.order_tms, 'MM') AS month,
                COUNT(DISTINCT o.order_id) AS order_count,
                SUM(oi.quantity * oi.unit_price) AS order_value,
                COUNT(DISTINCT c.customer_id) AS new_customers
            FROM orders o
            JOIN order_items oi ON o.order_id = oi.order_id
            JOIN customers c ON o.customer_id = c.customer_id
            WHERE o.order_tms >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -12)
              AND o.order_status NOT IN ('CANCELLED', 'REFUNDED')
            GROUP BY TRUNC(o.order_tms, 'MM')
        )
        SELECT 
            TO_CHAR(month, 'YYYY-MM') AS month,
            order_count,
            order_value,
            new_customers,
            ROUND((order_count - LAG(order_count) OVER (ORDER BY month)) / 
                  NULLIF(LAG(order_count) OVER (ORDER BY month), 0) * 100, 2) AS order_change_pct,
            ROUND((order_value - LAG(order_value) OVER (ORDER BY month)) / 
                  NULLIF(LAG(order_value) OVER (ORDER BY month), 0) * 100, 2) AS value_change_pct,
            ROUND((new_customers - LAG(new_customers) OVER (ORDER BY month)) / 
                  NULLIF(LAG(new_customers) OVER (ORDER BY month), 0) * 100, 2) AS customer_change_pct
        FROM monthly_data
        ORDER BY month DESC;

        RETURN v_cursor;
    END;
END dashboard_pkg;
/

prompt
prompt Creating trigger TRG_AUDIT_CUSTOMERS
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_customers
AFTER INSERT OR UPDATE OR DELETE ON customers
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ID=' || :NEW.customer_id || ', NAME=' || :NEW.full_name || ', EMAIL=' || :NEW.email_address;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('CUSTOMERS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ID=' || :OLD.customer_id || ', NAME=' || :OLD.full_name || ', EMAIL=' || :OLD.email_address;
    v_new_data := 'ID=' || :NEW.customer_id || ', NAME=' || :NEW.full_name || ', EMAIL=' || :NEW.email_address;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('CUSTOMERS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ID=' || :OLD.customer_id || ', NAME=' || :OLD.full_name || ', EMAIL=' || :OLD.email_address;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('CUSTOMERS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_INVENTORY
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_inventory
AFTER INSERT OR UPDATE OR DELETE ON inventory
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ID=' || :NEW.inventory_id || ', STORE=' || :NEW.store_id || ', PRODUCT=' || :NEW.product_id || ', COUNT=' || :NEW.product_inventory;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('INVENTORY', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ID=' || :OLD.inventory_id || ', COUNT=' || :OLD.product_inventory;
    v_new_data := 'ID=' || :NEW.inventory_id || ', COUNT=' || :NEW.product_inventory;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('INVENTORY', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ID=' || :OLD.inventory_id || ', PRODUCT=' || :OLD.product_id || ', STORE=' || :OLD.store_id;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('INVENTORY', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_ORDER_ITEMS
prompt ======================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_order_items
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ORDER=' || :NEW.order_id ||
                  ', PRODUCT=' || :NEW.product_id ||
                  ', QTY=' || :NEW.quantity ||
                  ', PRICE=' || :NEW.unit_price ||
                  ', ADDRESS=' || :NEW.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('ORDER_ITEMS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ORDER=' || :OLD.order_id ||
                  ', PRODUCT=' || :OLD.product_id ||
                  ', QTY=' || :OLD.quantity ||
                  ', ADDRESS=' || :OLD.delivery_address;

    v_new_data := 'ORDER=' || :NEW.order_id ||
                  ', PRODUCT=' || :NEW.product_id ||
                  ', QTY=' || :NEW.quantity ||
                  ', PRICE=' || :NEW.unit_price ||
                  ', ADDRESS=' || :NEW.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('ORDER_ITEMS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ORDER=' || :OLD.order_id ||
                  ', PRODUCT=' || :OLD.product_id ||
                  ', QTY=' || :OLD.quantity ||
                  ', ADDRESS=' || :OLD.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('ORDER_ITEMS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_ORDERS
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_orders
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ORDER_ID=' || :NEW.order_id || ', CUSTOMER=' || :NEW.customer_id || ', STORE=' || :NEW.store_id || ', STATUS=' || :NEW.order_status;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('ORDERS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ORDER_ID=' || :OLD.order_id || ', STATUS=' || :OLD.order_status;
    v_new_data := 'ORDER_ID=' || :NEW.order_id || ', STATUS=' || :NEW.order_status;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('ORDERS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ORDER_ID=' || :OLD.order_id || ', CUSTOMER=' || :OLD.customer_id || ', STATUS=' || :OLD.order_status;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('ORDERS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_PRODUCTS
prompt ===================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_products
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
  v_old_details VARCHAR2(4000);
  v_new_details VARCHAR2(4000);
BEGIN
  -- Ürün detaylarını BLOB'dan VARCHAR2'ye çevir (max 4000 karakter)
  IF INSERTING OR UPDATING THEN
    IF :NEW.product_details IS NOT NULL THEN
      v_new_details := DBMS_LOB.SUBSTR(UTL_RAW.CAST_TO_VARCHAR2(:NEW.product_details), 4000, 1);
    ELSE
      v_new_details := 'NULL';
    END IF;
  END IF;

  IF UPDATING OR DELETING THEN
    IF :OLD.product_details IS NOT NULL THEN
      v_old_details := DBMS_LOB.SUBSTR(UTL_RAW.CAST_TO_VARCHAR2(:OLD.product_details), 4000, 1);
    ELSE
      v_old_details := 'NULL';
    END IF;
  END IF;

  IF INSERTING THEN
    v_new_data := 'ID=' || :NEW.product_id || 
                  ', NAME=' || :NEW.product_name || 
                  ', PRICE=' || :NEW.unit_price ||
                  ', IMAGE=' || NVL(:NEW.image_filename, 'NULL') ||
                  ', DETAILS=' || v_new_details;

    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('PRODUCTS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ID=' || :OLD.product_id || 
                  ', NAME=' || :OLD.product_name || 
                  ', PRICE=' || :OLD.unit_price ||
                  ', IMAGE=' || NVL(:OLD.image_filename, 'NULL') ||
                  ', DETAILS=' || v_old_details;

    v_new_data := 'ID=' || :NEW.product_id || 
                  ', NAME=' || :NEW.product_name || 
                  ', PRICE=' || :NEW.unit_price ||
                  ', IMAGE=' || NVL(:NEW.image_filename, 'NULL') ||
                  ', DETAILS=' || v_new_details;

    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('PRODUCTS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ID=' || :OLD.product_id || 
                  ', NAME=' || :OLD.product_name || 
                  ', PRICE=' || :OLD.unit_price ||
                  ', IMAGE=' || NVL(:OLD.image_filename, 'NULL') ||
                  ', DETAILS=' || v_old_details;

    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('PRODUCTS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_SHIPMENTS
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_shipments
AFTER INSERT OR UPDATE OR DELETE ON shipments
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 
      'SHIPMENT_ID=' || :NEW.shipment_id ||
      ', STORE_ID=' || :NEW.store_id ||
      ', CUSTOMER_ID=' || :NEW.customer_id ||
      ', STATUS=' || :NEW.shipment_status ||
      ', ADDRESS=' || :NEW.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('SHIPMENTS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 
      'SHIPMENT_ID=' || :OLD.shipment_id ||
      ', STORE_ID=' || :OLD.store_id ||
      ', CUSTOMER_ID=' || :OLD.customer_id ||
      ', STATUS=' || :OLD.shipment_status ||
      ', ADDRESS=' || :OLD.delivery_address;

    v_new_data := 
      'SHIPMENT_ID=' || :NEW.shipment_id ||
      ', STORE_ID=' || :NEW.store_id ||
      ', CUSTOMER_ID=' || :NEW.customer_id ||
      ', STATUS=' || :NEW.shipment_status ||
      ', ADDRESS=' || :NEW.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('SHIPMENTS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 
      'SHIPMENT_ID=' || :OLD.shipment_id ||
      ', STORE_ID=' || :OLD.store_id ||
      ', CUSTOMER_ID=' || :OLD.customer_id ||
      ', STATUS=' || :OLD.shipment_status ||
      ', ADDRESS=' || :OLD.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('SHIPMENTS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_STORES
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_stores
AFTER INSERT OR UPDATE OR DELETE ON stores
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'STORE_ID=' || :NEW.store_id || ', NAME=' || :NEW.store_name || ', LOCATION=' || :NEW.physical_address ;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('STORES', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'STORE_ID=' || :OLD.store_id || ', NAME=' || :OLD.store_name || ', LOCATION=' || :NEW.physical_address;
    v_new_data := 'STORE_ID=' || :NEW.store_id || ', NAME=' || :NEW.store_name || ', LOCATION=' || :NEW.physical_address;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('STORES', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'STORE_ID=' || :OLD.store_id || ', NAME=' || :OLD.store_name || ', LOCATION=' || :NEW.physical_address;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('STORES', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_LOG_CUSTOMERS
prompt ==================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_log_customers
AFTER INSERT OR UPDATE OR DELETE ON customers
FOR EACH ROW
DECLARE
    v_old_data CLOB;
    v_new_data CLOB;
BEGIN
    IF INSERTING THEN
        v_new_data := 'NAME=' || :NEW.full_name || ', EMAIL=' || :NEW.email_address;
        INSERT INTO customer_log (customer_id, customer_name, email_address, operation, new_data, changed_by)
        VALUES (:NEW.customer_id, :NEW.full_name, :NEW.email_address, 'INSERT', v_new_data, USER);

    ELSIF UPDATING THEN
        v_old_data := 'NAME=' || :OLD.full_name || ', EMAIL=' || :OLD.email_address;
        v_new_data := 'NAME=' || :NEW.full_name || ', EMAIL=' || :NEW.email_address;
        INSERT INTO customer_log (customer_id, customer_name, email_address, operation, old_data, new_data, changed_by)
        VALUES (:NEW.customer_id, :NEW.full_name, :NEW.email_address, 'UPDATE', v_old_data, v_new_data, USER);

    ELSIF DELETING THEN
        v_old_data := 'NAME=' || :OLD.full_name || ', EMAIL=' || :OLD.email_address;
        INSERT INTO customer_log (customer_id, customer_name, email_address, operation, old_data, changed_by)
        VALUES (:OLD.customer_id, :OLD.full_name, :OLD.email_address, 'DELETE', v_old_data, USER);
    END IF;
END;
/

prompt
prompt Creating trigger TRG_LOG_INVENTORY
prompt ==================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_log_inventory
AFTER INSERT OR UPDATE OR DELETE ON inventory
FOR EACH ROW
DECLARE
    v_old_qty NUMBER;
    v_new_qty NUMBER;
BEGIN
    IF INSERTING THEN
        v_new_qty := :NEW.product_inventory;
        INSERT INTO inventory_log (inventory_id, store_id, product_id, change_amount, old_quantity, new_quantity, operation, changed_by)
        VALUES (:NEW.inventory_id, :NEW.store_id, :NEW.product_id, v_new_qty, NULL, v_new_qty, 'INSERT', USER);

    ELSIF UPDATING THEN
        v_old_qty := :OLD.product_inventory;
        v_new_qty := :NEW.product_inventory;
        INSERT INTO inventory_log (inventory_id, store_id, product_id, change_amount, old_quantity, new_quantity, operation, changed_by)
        VALUES (:NEW.inventory_id, :NEW.store_id, :NEW.product_id, v_new_qty - v_old_qty, v_old_qty, v_new_qty, 'UPDATE', USER);

    ELSIF DELETING THEN
        v_old_qty := :OLD.product_inventory;
        INSERT INTO inventory_log (inventory_id, store_id, product_id, change_amount, old_quantity, new_quantity, operation, changed_by)
        VALUES (:OLD.inventory_id, :OLD.store_id, :OLD.product_id, -v_old_qty, v_old_qty, NULL, 'DELETE', USER);
    END IF;
END;
/

prompt
prompt Creating trigger TRG_LOG_ORDER_ITEMS
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_log_order_items
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
DECLARE
    v_old_data CLOB;
    v_new_data CLOB;
    v_order_tms TIMESTAMP;
    v_customer_id NUMBER;
    v_store_id NUMBER;
BEGIN
    -- Sipariş tarihi, müşteri ve mağaza bilgilerini almak için join yapmaya izin yok triggerda
    -- Eğer gerekiyorsa, bu bilgileri uygulama tarafında set etmek veya başka yöntem kullanmak gerekir
    -- Burada örnek olarak NULL bırakıyoruz:
    v_order_tms := NULL;
    v_customer_id := NULL;
    v_store_id := NULL;

    IF INSERTING THEN
        v_new_data := 'LINE_ITEM_ID=' || :NEW.line_item_id ||
                      ', PRODUCT_ID=' || :NEW.product_id ||
                      ', UNIT_PRICE=' || TO_CHAR(:NEW.unit_price) ||
                      ', QUANTITY=' || TO_CHAR(:NEW.quantity) ||
                      ', SHIPMENT_ID=' || NVL(TO_CHAR(:NEW.shipment_id), 'NULL') ||
                      ', DELIVERY_ADDRESS=' || NVL(:NEW.delivery_address, 'NULL');
        INSERT INTO order_items_log (
          order_id, order_tms, customer_id, store_id, operation, new_data, changed_by, changed_at
        ) VALUES (
          :NEW.order_id, v_order_tms, v_customer_id, v_store_id, 'INSERT', v_new_data, USER, SYSTIMESTAMP
        );

    ELSIF UPDATING THEN
        v_old_data := 'LINE_ITEM_ID=' || :OLD.line_item_id ||
                      ', PRODUCT_ID=' || :OLD.product_id ||
                      ', UNIT_PRICE=' || TO_CHAR(:OLD.unit_price) ||
                      ', QUANTITY=' || TO_CHAR(:OLD.quantity) ||
                      ', SHIPMENT_ID=' || NVL(TO_CHAR(:OLD.shipment_id), 'NULL') ||
                      ', DELIVERY_ADDRESS=' || NVL(:OLD.delivery_address, 'NULL');
        v_new_data := 'LINE_ITEM_ID=' || :NEW.line_item_id ||
                      ', PRODUCT_ID=' || :NEW.product_id ||
                      ', UNIT_PRICE=' || TO_CHAR(:NEW.unit_price) ||
                      ', QUANTITY=' || TO_CHAR(:NEW.quantity) ||
                      ', SHIPMENT_ID=' || NVL(TO_CHAR(:NEW.shipment_id), 'NULL') ||
                      ', DELIVERY_ADDRESS=' || NVL(:NEW.delivery_address, 'NULL');
        INSERT INTO order_items_log (
          order_id, order_tms, customer_id, store_id, operation, old_data, new_data, changed_by, changed_at
        ) VALUES (
          :NEW.order_id, v_order_tms, v_customer_id, v_store_id, 'UPDATE', v_old_data, v_new_data, USER, SYSTIMESTAMP
        );

    ELSIF DELETING THEN
        v_old_data := 'LINE_ITEM_ID=' || :OLD.line_item_id ||
                      ', PRODUCT_ID=' || :OLD.product_id ||
                      ', UNIT_PRICE=' || TO_CHAR(:OLD.unit_price) ||
                      ', QUANTITY=' || TO_CHAR(:OLD.quantity) ||
                      ', SHIPMENT_ID=' || NVL(TO_CHAR(:OLD.shipment_id), 'NULL') ||
                      ', DELIVERY_ADDRESS=' || NVL(:OLD.delivery_address, 'NULL');
        INSERT INTO order_items_log (
          order_id, order_tms, customer_id, store_id, operation, old_data, changed_by, changed_at
        ) VALUES (
          :OLD.order_id, v_order_tms, v_customer_id, v_store_id, 'DELETE', v_old_data, USER, SYSTIMESTAMP
        );
    END IF;
END;
/

prompt
prompt Creating trigger TRG_LOG_ORDERS
prompt ===============================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_log_orders
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW
DECLARE
    v_old_data CLOB;
    v_new_data CLOB;
BEGIN
    IF INSERTING THEN
        v_new_data := 'ORDER_TMS=' || TO_CHAR(:NEW.order_tms,'YYYY-MM-DD HH24:MI:SS') || ', STATUS=' || :NEW.order_status;
        INSERT INTO order_log (order_id, order_tms, customer_id, store_id, operation, new_data, changed_by)
        VALUES (:NEW.order_id, :NEW.order_tms, :NEW.customer_id, :NEW.store_id, 'INSERT', v_new_data, USER);

    ELSIF UPDATING THEN
        v_old_data := 'STATUS=' || :OLD.order_status;
        v_new_data := 'STATUS=' || :NEW.order_status;
        INSERT INTO order_log (order_id, order_tms, customer_id, store_id, operation, old_data, new_data, changed_by)
        VALUES (:NEW.order_id, :NEW.order_tms, :NEW.customer_id, :NEW.store_id, 'UPDATE', v_old_data, v_new_data, USER);

    ELSIF DELETING THEN
        v_old_data := 'STATUS=' || :OLD.order_status;
        INSERT INTO order_log (order_id, order_tms, customer_id, store_id, operation, old_data, changed_by)
        VALUES (:OLD.order_id, :OLD.order_tms, :OLD.customer_id, :OLD.store_id, 'DELETE', v_old_data, USER);
    END IF;
END;
/

prompt
prompt Creating trigger TRG_LOG_PRODUCTS
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_log_products
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW
DECLARE
    v_old_data CLOB;
    v_new_data CLOB;
BEGIN
    IF INSERTING THEN
        v_new_data := 'NAME=' || :NEW.product_name || ', PRICE=' || :NEW.unit_price || ', DETAILS=' || TO_CHAR(UTL_RAW.CAST_TO_VARCHAR2(:NEW.product_details));
        
        INSERT INTO product_log (
            product_id, product_name, unit_price, operation, new_data, changed_by
        ) VALUES (
            :NEW.product_id, :NEW.product_name, :NEW.unit_price, 'INSERT', v_new_data, USER
        );

    ELSIF UPDATING THEN
        v_old_data := 'NAME=' || :OLD.product_name || ', PRICE=' || :OLD.unit_price || ', DETAILS=' || TO_CHAR(UTL_RAW.CAST_TO_VARCHAR2(:OLD.product_details));
        v_new_data := 'NAME=' || :NEW.product_name || ', PRICE=' || :NEW.unit_price || ', DETAILS=' || TO_CHAR(UTL_RAW.CAST_TO_VARCHAR2(:NEW.product_details));
        
        INSERT INTO product_log (
            product_id, product_name, unit_price, operation, old_data, new_data, changed_by
        ) VALUES (
            :NEW.product_id, :NEW.product_name, :NEW.unit_price, 'UPDATE', v_old_data, v_new_data, USER
        );

    ELSIF DELETING THEN
        v_old_data := 'NAME=' || :OLD.product_name || ', PRICE=' || :OLD.unit_price || ', DETAILS=' || TO_CHAR(UTL_RAW.CAST_TO_VARCHAR2(:OLD.product_details));
        
        INSERT INTO product_log (
            product_id, product_name, unit_price, operation, old_data, changed_by
        ) VALUES (
            :OLD.product_id, :OLD.product_name, :OLD.unit_price, 'DELETE', v_old_data, USER
        );
    END IF;
END;
/

prompt
prompt Creating trigger TRG_LOG_SHIPMENTS
prompt ==================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_log_shipments
AFTER INSERT OR UPDATE OR DELETE ON shipments
FOR EACH ROW
DECLARE
    v_old_data CLOB;
    v_new_data CLOB;
BEGIN
    IF INSERTING THEN
        v_new_data := 'STORE_ID=' || :NEW.store_id ||
                      ', CUSTOMER_ID=' || :NEW.customer_id ||
                      ', DELIVERY_ADDRESS=' || :NEW.delivery_address ||
                      ', SHIPMENT_STATUS=' || :NEW.shipment_status;

        INSERT INTO shipments_log (
            shipment_id, operation, new_data, changed_by
        ) VALUES (
            :NEW.shipment_id, 'INSERT', v_new_data, USER
        );

    ELSIF UPDATING THEN
        v_old_data := 'STORE_ID=' || :OLD.store_id ||
                      ', CUSTOMER_ID=' || :OLD.customer_id ||
                      ', DELIVERY_ADDRESS=' || :OLD.delivery_address ||
                      ', SHIPMENT_STATUS=' || :OLD.shipment_status;

        v_new_data := 'STORE_ID=' || :NEW.store_id ||
                      ', CUSTOMER_ID=' || :NEW.customer_id ||
                      ', DELIVERY_ADDRESS=' || :NEW.delivery_address ||
                      ', SHIPMENT_STATUS=' || :NEW.shipment_status;

        INSERT INTO shipments_log (
            shipment_id, operation, old_data, new_data, changed_by
        ) VALUES (
            :OLD.shipment_id, 'UPDATE', v_old_data, v_new_data, USER
        );

    ELSIF DELETING THEN
        v_old_data := 'STORE_ID=' || :OLD.store_id ||
                      ', CUSTOMER_ID=' || :OLD.customer_id ||
                      ', DELIVERY_ADDRESS=' || :OLD.delivery_address ||
                      ', SHIPMENT_STATUS=' || :OLD.shipment_status;

        INSERT INTO shipments_log (
            shipment_id, operation, old_data, changed_by
        ) VALUES (
            :OLD.shipment_id, 'DELETE', v_old_data, USER
        );
    END IF;
END;
/

prompt
prompt Creating trigger TRG_LOG_STORES
prompt ===============================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_log_stores
AFTER INSERT OR UPDATE OR DELETE ON stores
FOR EACH ROW
DECLARE
    v_old_data CLOB;
    v_new_data CLOB;
BEGIN
    IF INSERTING THEN
        v_new_data := 'NAME=' || :NEW.store_name || ', ADDRESS=' || COALESCE(:NEW.physical_address, :NEW.web_address);
        INSERT INTO store_log (store_id, store_name, physical_address, operation, new_data, changed_by)
        VALUES (:NEW.store_id, :NEW.store_name, COALESCE(:NEW.physical_address, :NEW.web_address), 'INSERT', v_new_data, USER);

    ELSIF UPDATING THEN
        v_old_data := 'NAME=' || :OLD.store_name || ', ADDRESS=' || COALESCE(:OLD.physical_address, :OLD.web_address);
        v_new_data := 'NAME=' || :NEW.store_name || ', ADDRESS=' || COALESCE(:NEW.physical_address, :NEW.web_address);
        INSERT INTO store_log (store_id, store_name, physical_address, operation, old_data, new_data, changed_by)
        VALUES (:NEW.store_id, :NEW.store_name, COALESCE(:NEW.physical_address, :NEW.web_address), 'UPDATE', v_old_data, v_new_data, USER);

    ELSIF DELETING THEN
        v_old_data := 'NAME=' || :OLD.store_name || ', ADDRESS=' || COALESCE(:OLD.physical_address, :OLD.web_address);
        INSERT INTO store_log (store_id, store_name, physical_address, operation, old_data, changed_by)
        VALUES (:OLD.store_id, :OLD.store_name, COALESCE(:OLD.physical_address, :OLD.web_address), 'DELETE', v_old_data, USER);
    END IF;
END;
/

prompt
prompt Creating trigger TRG_RESTOCK_ON_CANCEL_AND_REFUND
prompt =================================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_restock_on_cancel_and_refund
AFTER UPDATE OF order_status ON orders
FOR EACH ROW
WHEN (NEW.order_status IN( 'REFUNDED','CANCELLED'))
BEGIN
  restock_order_products(:NEW.order_id, :NEW.store_id);
END;
/


prompt Done
spool off
set define on
