prompt PL/SQL Developer Export User Objects for user SYSTEM@FREE
prompt Created by alioz on 7 Temmuz 2025 Pazartesi
set define off
spool all_queries.log

prompt
prompt Creating table AUDIT_LOG
prompt ========================
prompt
create table SYSTEM.AUDIT_LOG
(
  log_id     NUMBER generated by default on null as identity,
  table_name VARCHAR2(100),
  operation  VARCHAR2(10),
  changed_by VARCHAR2(100),
  changed_at TIMESTAMP(6) default CURRENT_TIMESTAMP,
  old_data   CLOB,
  new_data   CLOB
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.AUDIT_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table COUNTRIES
prompt ========================
prompt
create table SYSTEM.COUNTRIES
(
  country_id   CHAR(2),
  country_name VARCHAR2(60),
  region_id    NUMBER,
  constraint COUNTRY_C_ID_PK primary key (COUNTRY_ID)
)
organization index;
comment on table SYSTEM.COUNTRIES
  is 'country dimension table (snowflake)';
comment on column SYSTEM.COUNTRIES.country_id
  is 'primary key';
comment on column SYSTEM.COUNTRIES.country_name
  is 'country name';
comment on column SYSTEM.COUNTRIES.region_id
  is 'Region ID for the country. Foreign key to region_id column in the departments table.';
alter table SYSTEM.COUNTRIES
  add constraint COUNTRY_ID_NN
  check ("COUNTRY_ID" IS NOT NULL);

prompt
prompt Creating table CUSTOMERS
prompt ========================
prompt
create table SYSTEM.CUSTOMERS
(
  customer_id   INTEGER generated by default on null as identity (start with 393),
  email_address VARCHAR2(255 CHAR) not null,
  full_name     VARCHAR2(255 CHAR) not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.CUSTOMERS
  is 'dimension table';
comment on column SYSTEM.CUSTOMERS.customer_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.CUSTOMERS.email_address
  is 'The email address the person uses to access the account';
comment on column SYSTEM.CUSTOMERS.full_name
  is 'What this customer is called';
create index SYSTEM.CUSTOMERS_NAME_I on SYSTEM.CUSTOMERS (FULL_NAME)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.CUSTOMERS
  add constraint CUSTOMERS_PK primary key (CUSTOMER_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  )
  novalidate;
alter table SYSTEM.CUSTOMERS
  add constraint CUSTOMERS_EMAIL_U unique (EMAIL_ADDRESS)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PRODUCTS
prompt =======================
prompt
create table SYSTEM.PRODUCTS
(
  product_id         INTEGER generated by default on null as identity (start with 47),
  product_name       VARCHAR2(255 CHAR) not null,
  unit_price         NUMBER(10,2),
  product_details    BLOB,
  product_image      BLOB,
  image_mime_type    VARCHAR2(512 CHAR),
  image_filename     VARCHAR2(512 CHAR),
  image_charset      VARCHAR2(512 CHAR),
  image_last_updated DATE
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.PRODUCTS
  is 'dimension table';
comment on column SYSTEM.PRODUCTS.product_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.PRODUCTS.product_name
  is 'What a product is called';
comment on column SYSTEM.PRODUCTS.unit_price
  is 'The monetary value of one item of this product';
comment on column SYSTEM.PRODUCTS.product_details
  is 'Further details of the product stored in JSON format';
comment on column SYSTEM.PRODUCTS.product_image
  is 'A picture of the product';
comment on column SYSTEM.PRODUCTS.image_mime_type
  is 'The mime-type of the product image';
comment on column SYSTEM.PRODUCTS.image_filename
  is 'The name of the file loaded in the image column';
comment on column SYSTEM.PRODUCTS.image_charset
  is 'The character set used to encode the image';
comment on column SYSTEM.PRODUCTS.image_last_updated
  is 'The date the image was last changed';
alter table SYSTEM.PRODUCTS
  add constraint PRODUCTS_PK primary key (PRODUCT_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  )
  novalidate;
alter table SYSTEM.PRODUCTS
  add constraint PRODUCTS_JSON_C
  check ( product_details is json );

prompt
prompt Creating table STORES
prompt =====================
prompt
create table SYSTEM.STORES
(
  store_id          INTEGER generated by default on null as identity (start with 24),
  store_name        VARCHAR2(255 CHAR) not null,
  web_address       VARCHAR2(100 CHAR),
  physical_address  VARCHAR2(512 CHAR),
  latitude          NUMBER(9,6),
  longitude         NUMBER(9,6),
  logo              BLOB,
  logo_mime_type    VARCHAR2(512 CHAR),
  logo_filename     VARCHAR2(512 CHAR),
  logo_charset      VARCHAR2(512 CHAR),
  logo_last_updated DATE
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.STORES
  is 'Physical and virtual locations where people can purchase products';
comment on column SYSTEM.STORES.store_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.STORES.store_name
  is 'What the store is called';
comment on column SYSTEM.STORES.web_address
  is 'The URL of a virtual store';
comment on column SYSTEM.STORES.physical_address
  is 'The postal address of this location';
comment on column SYSTEM.STORES.latitude
  is 'The north-south position of a physical store';
comment on column SYSTEM.STORES.longitude
  is 'The east-west position of a physical store';
comment on column SYSTEM.STORES.logo
  is 'An image used by this store';
comment on column SYSTEM.STORES.logo_mime_type
  is 'The mime-type of the store logo';
comment on column SYSTEM.STORES.logo_filename
  is 'The name of the file loaded in the image column';
comment on column SYSTEM.STORES.logo_charset
  is 'The character set used to encode the image';
comment on column SYSTEM.STORES.logo_last_updated
  is 'The date the image was last changed';
alter table SYSTEM.STORES
  add constraint STORES_PK primary key (STORE_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.STORES
  add constraint STORE_NAME_U unique (STORE_NAME)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.STORES
  add constraint STORE_AT_LEAST_ONE_ADDRESS_C
  check (
    web_address IS NOT NULL or physical_address IS NOT NULL
  );

prompt
prompt Creating table INVENTORY
prompt ========================
prompt
create table SYSTEM.INVENTORY
(
  inventory_id      INTEGER generated by default on null as identity (start with 567),
  store_id          INTEGER not null,
  product_id        INTEGER not null,
  product_inventory INTEGER not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.INVENTORY
  is 'Details of the quantity of stock available for products at each location';
comment on column SYSTEM.INVENTORY.inventory_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.INVENTORY.store_id
  is 'Which location the goods are located at';
comment on column SYSTEM.INVENTORY.product_id
  is 'Which item this stock is for';
comment on column SYSTEM.INVENTORY.product_inventory
  is 'The current quantity in stock';
create index SYSTEM.INVENTORY_PRODUCT_ID_I on SYSTEM.INVENTORY (PRODUCT_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.INVENTORY
  add constraint INVENTORY_PK primary key (INVENTORY_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.INVENTORY
  add constraint INVENTORY_STORE_PRODUCT_U unique (STORE_ID, PRODUCT_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.INVENTORY
  add constraint INVENTORY_PRODUCT_ID_FK foreign key (PRODUCT_ID)
  references SYSTEM.PRODUCTS (PRODUCT_ID);
alter table SYSTEM.INVENTORY
  add constraint INVENTORY_STORE_ID_FK foreign key (STORE_ID)
  references SYSTEM.STORES (STORE_ID);

prompt
prompt Creating table INVENTORY_LOG
prompt ============================
prompt
create table SYSTEM.INVENTORY_LOG
(
  log_id        NUMBER generated by default on null as identity,
  inventory_id  NUMBER,
  store_id      NUMBER,
  product_id    NUMBER,
  change_amount NUMBER,
  old_quantity  NUMBER,
  new_quantity  NUMBER,
  action        VARCHAR2(20),
  changed_at    TIMESTAMP(6) default SYSTIMESTAMP,
  changed_by    VARCHAR2(100)
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.INVENTORY_LOG
  add primary key (LOG_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table LOCATIONS
prompt ========================
prompt
create table SYSTEM.LOCATIONS
(
  location_id    NUMBER(4) not null,
  street_address VARCHAR2(40),
  postal_code    VARCHAR2(12),
  city           VARCHAR2(30),
  state_province VARCHAR2(25),
  country_id     CHAR(2)
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.LOCATIONS
  is 'Locations table that contains specific address of a specific office,
warehouse, and/or production site of a company. Does not store addresses /
locations of customers. references with the departments and countries tables. ';
comment on column SYSTEM.LOCATIONS.location_id
  is 'Primary key of locations table';
comment on column SYSTEM.LOCATIONS.street_address
  is 'Street address of an office, warehouse, or production site of a company.
Contains building number and street name';
comment on column SYSTEM.LOCATIONS.postal_code
  is 'Postal code of the location of an office, warehouse, or production site 
of a company. ';
comment on column SYSTEM.LOCATIONS.city
  is 'A not null column that shows city where an office, warehouse, or 
production site of a company is located. ';
comment on column SYSTEM.LOCATIONS.state_province
  is 'State or Province where an office, warehouse, or production site of a 
company is located.';
comment on column SYSTEM.LOCATIONS.country_id
  is 'Country where an office, warehouse, or production site of a company is
located. Foreign key to country_id column of the countries table.';
create index SYSTEM.LOC_CITY_IX on SYSTEM.LOCATIONS (CITY)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.LOC_COUNTRY_IX on SYSTEM.LOCATIONS (COUNTRY_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.LOC_STATE_PROVINCE_IX on SYSTEM.LOCATIONS (STATE_PROVINCE)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.LOCATIONS
  add constraint LOC_ID_PK primary key (LOCATION_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.LOCATIONS
  add constraint LOC_C_ID_FK foreign key (COUNTRY_ID)
  references SYSTEM.COUNTRIES (COUNTRY_ID);
alter table SYSTEM.LOCATIONS
  add constraint LOC_CITY_NN
  check ("CITY" IS NOT NULL);

prompt
prompt Creating table ORDERS
prompt =====================
prompt
create table SYSTEM.ORDERS
(
  order_id     INTEGER generated by default on null as identity (start with 1951),
  order_tms    TIMESTAMP(6) not null,
  customer_id  INTEGER not null,
  order_status VARCHAR2(10 CHAR) not null,
  store_id     INTEGER not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.ORDERS
  is 'Details of who made purchases where';
comment on column SYSTEM.ORDERS.order_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.ORDERS.order_tms
  is 'When the order was placed';
comment on column SYSTEM.ORDERS.customer_id
  is 'Who placed this order';
comment on column SYSTEM.ORDERS.order_status
  is 'What state the order is in. Valid values are:
OPEN - the order is in progress
PAID - money has been received from the customer for this order
SHIPPED - the products have been dispatched to the customer
COMPLETE - the customer has received the order
CANCELLED - the customer has stopped the order
REFUNDED - there has been an issue with the order and the money has been returned to the customer';
comment on column SYSTEM.ORDERS.store_id
  is 'Where this order was placed';
create index SYSTEM.IDX_ORDERS_ORDER_TMS on SYSTEM.ORDERS (ORDER_TMS)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.ORDERS_CUSTOMER_ID_I on SYSTEM.ORDERS (CUSTOMER_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.ORDERS_STORE_ID_I on SYSTEM.ORDERS (STORE_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDERS
  add constraint ORDERS_PK primary key (ORDER_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDERS
  add constraint ORDERS_CUSTOMER_ID_FK foreign key (CUSTOMER_ID)
  references SYSTEM.CUSTOMERS (CUSTOMER_ID);
alter table SYSTEM.ORDERS
  add constraint ORDERS_STORE_ID_FK foreign key (STORE_ID)
  references SYSTEM.STORES (STORE_ID);
alter table SYSTEM.ORDERS
  add constraint ORDERS_STATUS_C
  check ( order_status in
                    ( 'CANCELLED','COMPLETE','OPEN','PAID','REFUNDED','SHIPPED'));

prompt
prompt Creating table SHIPMENTS
prompt ========================
prompt
create table SYSTEM.SHIPMENTS
(
  shipment_id      INTEGER generated by default on null as identity (start with 2027),
  store_id         INTEGER not null,
  customer_id      INTEGER not null,
  delivery_address VARCHAR2(512 CHAR) not null,
  shipment_status  VARCHAR2(100 CHAR) not null
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.SHIPMENTS
  is 'Details of where ordered goods will be delivered';
comment on column SYSTEM.SHIPMENTS.shipment_id
  is 'Auto-incrementing primary key';
comment on column SYSTEM.SHIPMENTS.store_id
  is 'Which location the goods will be transported from';
comment on column SYSTEM.SHIPMENTS.customer_id
  is 'Who this shipment is for';
comment on column SYSTEM.SHIPMENTS.delivery_address
  is 'Where the goods will be transported to';
comment on column SYSTEM.SHIPMENTS.shipment_status
  is 'The current status of the shipment. Valid values are:
CREATED - the shipment is ready for order assignment
SHIPPED - the goods have been dispatched
IN-TRANSIT - the goods are en-route to their destination
DELIVERED - the good have arrived at their destination';
create index SYSTEM.SHIPMENTS_CUSTOMER_ID_I on SYSTEM.SHIPMENTS (CUSTOMER_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.SHIPMENTS_STORE_ID_I on SYSTEM.SHIPMENTS (STORE_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.SHIPMENTS
  add constraint SHIPMENTS_PK primary key (SHIPMENT_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.SHIPMENTS
  add constraint SHIPMENTS_CUSTOMER_ID_FK foreign key (CUSTOMER_ID)
  references SYSTEM.CUSTOMERS (CUSTOMER_ID);
alter table SYSTEM.SHIPMENTS
  add constraint SHIPMENTS_STORE_ID_FK foreign key (STORE_ID)
  references SYSTEM.STORES (STORE_ID);
alter table SYSTEM.SHIPMENTS
  add constraint SHIPMENT_STATUS_C
  check ( shipment_status in
                    ( 'CREATED', 'SHIPPED', 'IN-TRANSIT', 'DELIVERED'));

prompt
prompt Creating table ORDER_ITEMS
prompt ==========================
prompt
create table SYSTEM.ORDER_ITEMS
(
  order_id     INTEGER not null,
  line_item_id INTEGER not null,
  product_id   INTEGER not null,
  unit_price   NUMBER(10,2) not null,
  quantity     INTEGER not null,
  shipment_id  INTEGER
)
tablespace SYSTEM
  pctfree 10
  pctused 40
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table SYSTEM.ORDER_ITEMS
  is 'Details of which products the customer has purchased in an order';
comment on column SYSTEM.ORDER_ITEMS.order_id
  is 'The order these products belong to';
comment on column SYSTEM.ORDER_ITEMS.line_item_id
  is 'An incrementing number, starting at one for each order';
comment on column SYSTEM.ORDER_ITEMS.product_id
  is 'Which item was purchased';
comment on column SYSTEM.ORDER_ITEMS.unit_price
  is 'How much the customer paid for one item of the product';
comment on column SYSTEM.ORDER_ITEMS.quantity
  is 'How many items of this product the customer purchased';
comment on column SYSTEM.ORDER_ITEMS.shipment_id
  is 'Where this product will be delivered';
create index SYSTEM.IDX_ORDER_ITEMS_ORDER_ID on SYSTEM.ORDER_ITEMS (ORDER_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index SYSTEM.ORDER_ITEMS_SHIPMENT_ID_I on SYSTEM.ORDER_ITEMS (SHIPMENT_ID)
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_PK primary key (ORDER_ID, LINE_ITEM_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_PRODUCT_U unique (PRODUCT_ID, ORDER_ID)
  using index
  tablespace SYSTEM
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_ORDER_ID_FK foreign key (ORDER_ID)
  references SYSTEM.ORDERS (ORDER_ID);
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_PRODUCT_ID_FK foreign key (PRODUCT_ID)
  references SYSTEM.PRODUCTS (PRODUCT_ID);
alter table SYSTEM.ORDER_ITEMS
  add constraint ORDER_ITEMS_SHIPMENT_ID_FK foreign key (SHIPMENT_ID)
  references SYSTEM.SHIPMENTS (SHIPMENT_ID);

prompt
prompt Creating view CUSTOMER_ORDER_PRODUCTS
prompt =====================================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.CUSTOMER_ORDER_PRODUCTS AS
SELECT o.order_id, o.order_tms, o.order_status,
         c.customer_id, c.email_address, c.full_name,
         SUM ( oi.quantity * oi.unit_price ) order_total,
         LISTAGG (
           p.product_name, ', '
           ON OVERFLOW TRUNCATE '...' WITH COUNT
         ) WITHIN GROUP ( ORDER BY oi.line_item_id ) items
  FROM   orders o
  JOIN   order_items oi
  ON     o.order_id = oi.order_id
  JOIN   customers c
  ON     o.customer_id = c.customer_id
  JOIN   products p
  ON     oi.product_id = p.product_id
  GROUP  BY o.order_id, o.order_tms, o.order_status,
         c.customer_id, c.email_address, c.full_name;
comment on table SYSTEM.CUSTOMER_ORDER_PRODUCTS is 'A summary of who placed each order and what they bought';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ORDER_ID is 'The primary key of the order';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ORDER_TMS is 'The date and time the order was placed';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ORDER_STATUS is 'The current state of this order';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.CUSTOMER_ID is 'The primary key of the customer';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.EMAIL_ADDRESS is 'The email address the person uses to access the account';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.FULL_NAME is 'What this customer is called';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ORDER_TOTAL is 'The total amount the customer paid for the order';
comment on column SYSTEM.CUSTOMER_ORDER_PRODUCTS.ITEMS is 'A comma-separated list naming the products in this order';

prompt
prompt Creating view INVENTORY_VIEW
prompt ============================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.INVENTORY_VIEW AS
SELECT
  i.inventory_id,
  s.store_id,
  s.store_name,
  p.product_id,
  p.product_name,
  p.unit_price,
  i.product_inventory
FROM inventory i
JOIN products p ON i.product_id = p.product_id
JOIN stores s ON i.store_id = s.store_id
ORDER BY i.inventory_id ASC;

prompt
prompt Creating view ORDERS_VIEW
prompt =========================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.ORDERS_VIEW AS
SELECT
    o.order_id,
    o.order_tms,
    o.order_status,
    c.full_name AS customer_name,
    s.store_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN stores s ON o.store_id = s.store_id
ORDER BY o.order_tms DESC;

prompt
prompt Creating view PRODUCT_ORDERS
prompt ============================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.PRODUCT_ORDERS AS
SELECT p.product_name, o.order_status,
         SUM ( oi.quantity * oi.unit_price ) total_sales,
         COUNT (*) order_count
  FROM   orders o
  JOIN   order_items oi
  ON     o.order_id = oi.order_id
  JOIN   customers c
  ON     o.customer_id = c.customer_id
  JOIN   products p
  ON     oi.product_id = p.product_id
  GROUP  BY p.product_name, o.order_status;
comment on table SYSTEM.PRODUCT_ORDERS is 'A summary of the state of the orders placed for each product';
comment on column SYSTEM.PRODUCT_ORDERS.PRODUCT_NAME is 'What this product is called';
comment on column SYSTEM.PRODUCT_ORDERS.ORDER_STATUS is 'The current state of these order';
comment on column SYSTEM.PRODUCT_ORDERS.TOTAL_SALES is 'The total value of orders placed';
comment on column SYSTEM.PRODUCT_ORDERS.ORDER_COUNT is 'The total number of orders placed';

prompt
prompt Creating view PRODUCT_PRIVS
prompt ===========================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.PRODUCT_PRIVS AS
SELECT PRODUCT, USERID, ATTRIBUTE, SCOPE,
         NUMERIC_VALUE, CHAR_VALUE, DATE_VALUE, LONG_VALUE
  FROM SQLPLUS_PRODUCT_PROFILE
  WHERE USERID = 'PUBLIC' OR
        USERID LIKE SYS_CONTEXT('USERENV','CURRENT_USER');

prompt
prompt Creating view PRODUCT_REVIEWS
prompt =============================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.PRODUCT_REVIEWS AS
SELECT p.product_name, r.rating,
         ROUND (
           AVG ( r.rating ) over (
             PARTITION BY product_name
           ),
           2
         ) avg_rating,
         r.review
  FROM   products p,
         JSON_TABLE (
           p.product_details, '$'
           COLUMNS (
             NESTED PATH '$.reviews[*]'
             COLUMNS (
               rating INTEGER PATH '$.rating',
               review VARCHAR2(4000) PATH '$.review'
             )
           )
         ) r;
comment on table SYSTEM.PRODUCT_REVIEWS is 'A relational view of the reviews stored in the JSON for each product';
comment on column SYSTEM.PRODUCT_REVIEWS.PRODUCT_NAME is 'What this product is called';
comment on column SYSTEM.PRODUCT_REVIEWS.RATING is 'The review score the customer has placed. Range is 1-10';
comment on column SYSTEM.PRODUCT_REVIEWS.AVG_RATING is 'The mean of the review scores for this product';
comment on column SYSTEM.PRODUCT_REVIEWS.REVIEW is 'The text of the review';

prompt
prompt Creating view STORE_ORDERS
prompt ==========================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.STORE_ORDERS AS
SELECT CASE
           grouping_id ( store_name, order_status )
           WHEN 1 THEN 'STORE TOTAL'
           WHEN 2 THEN 'STATUS TOTAL'
           WHEN 3 THEN 'GRAND TOTAL'
         END total,
         s.store_name,
         COALESCE ( s.web_address, s.physical_address ) address,
         s.latitude, s.longitude,
         o.order_status,
         COUNT ( DISTINCT o.order_id ) order_count,
         SUM ( oi.quantity * oi.unit_price ) total_sales
  FROM   stores s
  JOIN   orders o
  ON     s.store_id = o.store_id
  JOIN   order_items oi
  ON     o.order_id = oi.order_id
  GROUP  BY GROUPING SETS (
    ( s.store_name, COALESCE ( s.web_address, s.physical_address ), s.latitude, s.longitude ),
    ( s.store_name, COALESCE ( s.web_address, s.physical_address ), s.latitude, s.longitude, o.order_status ),
    o.order_status,
    ()
  );
comment on table SYSTEM.STORE_ORDERS is 'A summary of what was purchased at each location, including summaries each store, order status and overall total';
comment on column SYSTEM.STORE_ORDERS.TOTAL is 'Indicates what type of total is displayed, including Store, Status, or Grand Totals';
comment on column SYSTEM.STORE_ORDERS.STORE_NAME is 'What the store is called';
comment on column SYSTEM.STORE_ORDERS.ADDRESS is 'The physical or virtual location of this store';
comment on column SYSTEM.STORE_ORDERS.LATITUDE is 'The north-south position of a physical store';
comment on column SYSTEM.STORE_ORDERS.LONGITUDE is 'The east-west position of a physical store';
comment on column SYSTEM.STORE_ORDERS.ORDER_STATUS is 'The current state of this order';
comment on column SYSTEM.STORE_ORDERS.ORDER_COUNT is 'The total number of orders placed';
comment on column SYSTEM.STORE_ORDERS.TOTAL_SALES is 'The total value of orders placed';

prompt
prompt Creating view VW_INVENTORY_STATS
prompt ================================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.VW_INVENTORY_STATS AS
SELECT 
    SUM(i.product_inventory) AS total_products,
    SUM(i.product_inventory * p.unit_price) AS total_value
FROM 
    inventory i
JOIN 
    products p ON i.product_id = p.product_id;

prompt
prompt Creating view VW_ORDER_STATS
prompt ============================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.VW_ORDER_STATS AS
SELECT 
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(oi.quantity * oi.unit_price) AS total_cost
FROM 
    order_items oi
JOIN 
    orders o ON oi.order_id = o.order_id 
WHERE 
    o.order_status NOT IN ('CANCELLED', 'REFUNDED');

prompt
prompt Creating view VW_USER_COUNT
prompt ===========================
prompt
CREATE OR REPLACE FORCE VIEW SYSTEM.VW_USER_COUNT AS
SELECT COUNT(*) AS customer_id FROM customers;

prompt
prompt Creating materialized view MV_DAILY_STATS
prompt =========================================
prompt
CREATE MATERIALIZED VIEW SYSTEM.MV_DAILY_STATS
REFRESH COMPLETE ON DEMAND
AS
SELECT 
  TRUNC(SYSDATE) AS report_date,
  c.user_count,
  i.total_products,
  i.total_value,
  o.today_orders,
  o.today_sales
FROM 
  (SELECT COUNT(*) AS user_count FROM customers) c,
  (SELECT 
     SUM(product_inventory) AS total_products,
     SUM(product_inventory * unit_price) AS total_value
   FROM inventory i JOIN products p ON i.product_id = p.product_id) i,
  (SELECT 
     COUNT(*) AS today_orders,
     NVL(SUM(oi.quantity * oi.unit_price), 0) AS today_sales
   FROM order_items oi JOIN orders o ON oi.order_id = o.order_id
   WHERE TRUNC(o.order_tms) = TRUNC(SYSDATE)) o;

prompt
prompt Creating package DASHBOARD_PKG
prompt ==============================
prompt
CREATE OR REPLACE NONEDITIONABLE PACKAGE SYSTEM.dashboard_pkg AS
    -- Dashboard için tüm istatistikleri getiren fonksiyon
    FUNCTION get_dashboard_stats RETURN SYS_REFCURSOR;

    -- Aylık değişim verilerini getiren fonksiyon
    FUNCTION get_monthly_changes RETURN SYS_REFCURSOR;
END dashboard_pkg;
/

prompt
prompt Creating type ORDER_ITEM_REC
prompt ============================
prompt
CREATE OR REPLACE NONEDITIONABLE TYPE SYSTEM.order_item_rec AS OBJECT (
  product_id NUMBER,
  quantity NUMBER,
  unit_price NUMBER
);
/

prompt
prompt Creating type ORDER_ITEM_TABLE
prompt ==============================
prompt
CREATE OR REPLACE NONEDITIONABLE TYPE SYSTEM.order_item_table AS TABLE OF order_item_rec;
/

prompt
prompt Creating type T_STOCK_ROW
prompt =========================
prompt
CREATE OR REPLACE NONEDITIONABLE TYPE SYSTEM.t_stock_row AS OBJECT (
    inventory_id NUMBER(38,0),
    product_inventory NUMBER(38,0)
);
/

prompt
prompt Creating function GET_ORDER_TOTAL
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE FUNCTION SYSTEM.get_order_total(p_order_id IN NUMBER)
RETURN NUMBER IS
  v_total NUMBER := 0
/

prompt
prompt Creating procedure ADD_CUSTOMER
prompt ===============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.add_customer (
  p_email IN VARCHAR2,
  p_name  IN VARCHAR2
) IS
BEGIN
  INSERT INTO customers (email_address, full_name)
  VALUES (p_email, p_name);
  COMMIT;
END;
/

prompt
prompt Creating procedure ADD_INVENTORY
prompt ================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.ADD_INVENTORY (
  p_store_id       IN  NUMBER,
  p_product_id     IN  NUMBER,
  p_product_amount IN  NUMBER,
  p_old_amount     OUT NUMBER,
  p_new_amount     OUT NUMBER,
  p_changed_by     IN  VARCHAR2 DEFAULT 'SYSTEM'  -- opsiyonel
) IS
  v_inventory_id NUMBER;
BEGIN
  BEGIN
    -- Envanterde mevcut kayıt var mı kontrolü ve eski miktarı al
    SELECT inventory_id, product_inventory
    INTO v_inventory_id, p_old_amount
    FROM inventory
    WHERE store_id = p_store_id AND product_id = p_product_id
    FOR UPDATE NOWAIT;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      -- Kayıt yoksa eski miktar 0 olarak ayarlanır
      v_inventory_id := NULL;
      p_old_amount := 0;
  END;

  IF v_inventory_id IS NOT NULL THEN
    -- Var olan kaydı güncelle
    UPDATE inventory
    SET product_inventory = product_inventory + p_product_amount
    WHERE inventory_id = v_inventory_id;

    SELECT product_inventory INTO p_new_amount FROM inventory WHERE inventory_id = v_inventory_id;
  ELSE
    -- Yeni kayıt ekle
    SELECT inventory_seq.NEXTVAL INTO v_inventory_id FROM dual;

    INSERT INTO inventory (inventory_id, store_id, product_id, product_inventory)
    VALUES (v_inventory_id, p_store_id, p_product_id, p_product_amount);

    p_new_amount := p_product_amount;
  END IF;

  -- Değişiklikleri logla
  INSERT INTO inventory_log (
    inventory_id, store_id, product_id,
    change_amount, old_quantity, new_quantity,
    action, changed_at, changed_by
  ) VALUES (
    v_inventory_id, p_store_id, p_product_id,
    p_product_amount, p_old_amount, p_new_amount,
    'ADD', SYSTIMESTAMP, p_changed_by
  );

  COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END ADD_INVENTORY;
/

prompt
prompt Creating procedure ADD_ORDER
prompt ============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.add_order (
  p_customer_id IN NUMBER,
  p_store_id    IN NUMBER,
  p_order_items IN order_item_table,
  p_order_id    OUT NUMBER
) AS
  v_line_item_id NUMBER := 1;
BEGIN
  INSERT INTO orders(order_tms, customer_id, order_status, store_id)
  VALUES (SYSTIMESTAMP, p_customer_id, 'OPEN', p_store_id)
  RETURNING order_id INTO p_order_id;

  FOR i IN 1 .. p_order_items.COUNT LOOP
    DECLARE
      v_quantity_needed NUMBER := p_order_items(i).quantity;
      v_stock_accum NUMBER := 0;
      v_idx PLS_INTEGER := 1;

      CURSOR c_inv IS
        SELECT inventory_id, product_inventory
        FROM inventory
        WHERE store_id = p_store_id AND product_id = p_order_items(i).product_id
        ORDER BY inventory_id
        FOR UPDATE;

      TYPE inv_tab_type IS TABLE OF c_inv%ROWTYPE INDEX BY PLS_INTEGER;
      v_inv_tab inv_tab_type;
    BEGIN
      -- Cursor'u aç ve satırları diziye al
      OPEN c_inv;
      FETCH c_inv BULK COLLECT INTO v_inv_tab;
      CLOSE c_inv;

      -- Toplam stok hesapla
      FOR idx IN 1 .. v_inv_tab.COUNT LOOP
        v_stock_accum := v_stock_accum + v_inv_tab(idx).product_inventory;
      END LOOP;

      IF v_stock_accum < v_quantity_needed THEN
        RAISE_APPLICATION_ERROR(-20001, 'Yeterli stok yok: Ürün ' || p_order_items(i).product_id);
      END IF;

      -- FIFO mantığı ile stok düşür (artık silme yok)
      WHILE v_quantity_needed > 0 AND v_idx <= v_inv_tab.COUNT LOOP
        IF v_inv_tab(v_idx).product_inventory <= v_quantity_needed THEN
          UPDATE inventory
          SET product_inventory = 0
          WHERE inventory_id = v_inv_tab(v_idx).inventory_id;
          v_quantity_needed := v_quantity_needed - v_inv_tab(v_idx).product_inventory;
        ELSE
          UPDATE inventory
          SET product_inventory = product_inventory - v_quantity_needed
          WHERE inventory_id = v_inv_tab(v_idx).inventory_id;
          v_quantity_needed := 0;
        END IF;
        v_idx := v_idx + 1;
      END LOOP;

      -- Sipariş kalemini ekle
      INSERT INTO order_items(order_id, line_item_id, product_id, unit_price, quantity)
      VALUES (p_order_id, v_line_item_id, p_order_items(i).product_id,
              p_order_items(i).unit_price, p_order_items(i).quantity);

      v_line_item_id := v_line_item_id + 1;
    END;
  END LOOP;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/

prompt
prompt Creating procedure ADD_PRODUCT
prompt ==============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.ADD_PRODUCT(
  p_product_name     IN VARCHAR2,
  p_unit_price       IN NUMBER,
  p_product_details  IN BLOB DEFAULT NULL,
  p_product_image    IN BLOB DEFAULT NULL,
  p_image_mime_type  IN VARCHAR2 DEFAULT NULL,
  p_image_filename   IN VARCHAR2 DEFAULT NULL,
  p_image_charset    IN VARCHAR2 DEFAULT NULL
) IS
BEGIN
  INSERT INTO products (
    product_name,
    unit_price,
    product_details,
    product_image,
    image_mime_type,
    image_filename,
    image_charset,
    image_last_updated
  )
  VALUES (
    p_product_name,
    p_unit_price,
    p_product_details,
    p_product_image,
    p_image_mime_type,
    p_image_filename,
    p_image_charset,
    SYSDATE
  );

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END ADD_PRODUCT;
/

prompt
prompt Creating procedure DELETE_CUSTOMER
prompt ==================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_CUSTOMER(p_customer_id IN NUMBER) IS
BEGIN
  -- Öncelikle müşterinin tüm siparişlerini ve order_items silmek gerekebilir

  FOR order_rec IN (SELECT order_id FROM orders WHERE customer_id = p_customer_id) LOOP
    DELETE FROM order_items WHERE order_id = order_rec.order_id;
    DELETE FROM orders WHERE order_id = order_rec.order_id;
  END LOOP;

  -- Müşteriyi sil
  DELETE FROM customers WHERE customer_id = p_customer_id;

  COMMIT;
END DELETE_CUSTOMER;
/

prompt
prompt Creating procedure DELETE_INVENTORY
prompt ===================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_INVENTORY(p_inventory_id IN NUMBER) IS
BEGIN
  DELETE FROM inventory WHERE inventory_id = p_inventory_id;
  COMMIT;
END DELETE_INVENTORY;
/

prompt
prompt Creating procedure DELETE_ORDER
prompt ===============================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_ORDER(p_order_id IN NUMBER) IS
BEGIN
  -- Öncelikle ilgili order_items kayıtlarını silelim (Foreign Key varsa)
  DELETE FROM order_items WHERE order_id = p_order_id;
  
  -- Ardından orders tablosundan siparişi silelim
  DELETE FROM orders WHERE order_id = p_order_id;
  
  COMMIT;
END DELETE_ORDER;
/

prompt
prompt Creating procedure DELETE_PRODUCT
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_PRODUCT(p_product_id IN INTEGER) IS
BEGIN
  DELETE FROM products
  WHERE product_id = p_product_id;

  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END DELETE_PRODUCT;
/

prompt
prompt Creating procedure DELETE_PRODUCT_IMAGE
prompt =======================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.DELETE_PRODUCT_IMAGE(p_product_id IN NUMBER) AS
  v_image_exists NUMBER := 0;
BEGIN
  -- Önce gerçekten resim var mı kontrol et
  SELECT COUNT(*) INTO v_image_exists
  FROM products
  WHERE product_id = p_product_id AND product_image IS NOT NULL;

  IF v_image_exists = 1 THEN
    UPDATE products
    SET product_image = NULL,
        image_mime_type = NULL,
        image_filename = NULL,
        image_charset = NULL,
        image_last_updated = SYSDATE
    WHERE product_id = p_product_id;

    COMMIT;
  END IF;
END;
/

prompt
prompt Creating procedure PRINT_ORDER_TOTAL
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.print_order_total(p_order_id IN NUMBER) IS
  v_total NUMBER := 0;
BEGIN
  SELECT SUM(unit_price * quantity)
  INTO v_total
  FROM order_items
  WHERE order_id = p_order_id;

  DBMS_OUTPUT.PUT_LINE('Total: ' || NVL(v_total, 0));
END;
/

prompt
prompt Creating procedure RESTOCK_ORDER_PRODUCTS
prompt =========================================
prompt
CREATE OR REPLACE NONEDITIONABLE PROCEDURE SYSTEM.restock_order_products(
  p_order_id IN NUMBER,
  p_store_id IN NUMBER
)
IS
BEGIN
  FOR rec IN (
    SELECT product_id, SUM(quantity) AS total_quantity
    FROM order_items
    WHERE order_id = p_order_id
    GROUP BY product_id
  ) LOOP
    UPDATE inventory
    SET product_inventory = product_inventory + rec.total_quantity
    WHERE product_id = rec.product_id
      AND store_id = p_store_id;
  END LOOP;
END;
/

prompt
prompt Creating package body DASHBOARD_PKG
prompt ===================================
prompt
CREATE OR REPLACE NONEDITIONABLE PACKAGE BODY SYSTEM.dashboard_pkg AS
    FUNCTION get_dashboard_stats RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
        SELECT 
            (SELECT customer_id FROM vw_user_count) AS user_count,
            (SELECT total_products FROM vw_inventory_stats) AS product_count,
            (SELECT total_value FROM vw_inventory_stats) AS inventory_value,
            (SELECT total_orders FROM vw_order_stats) AS order_count,
            (SELECT total_cost FROM vw_order_stats) AS order_value,
            (SELECT COUNT(*) FROM inventory i WHERE i.product_inventory < 10) AS low_stock_items
            -- Min stock seviyesi için sabit değer kullanıldı
        FROM dual;

        RETURN v_cursor;
    END;

    FUNCTION get_monthly_changes RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
        WITH monthly_data AS (
            SELECT 
                TRUNC(o.order_tms, 'MM') AS month,
                COUNT(DISTINCT o.order_id) AS order_count,
                SUM(oi.quantity * oi.unit_price) AS order_value,
                0 AS new_customers -- Müşteri kayıt tarihi olmadığı için 0 olarak ayarlandı
            FROM orders o
            JOIN order_items oi ON o.order_id = oi.order_id
            WHERE o.order_tms >= ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -12)
              AND o.order_status NOT IN ('CANCELLED', 'REFUNDED')
            GROUP BY TRUNC(o.order_tms, 'MM')
        )
        SELECT 
            TO_CHAR(month, 'YYYY-MM') AS month,
            order_count,
            order_value,
            new_customers,
            ROUND((order_count - LAG(order_count) OVER (ORDER BY month)) / 
                  NULLIF(LAG(order_count) OVER (ORDER BY month), 0) * 100, 2) AS order_change_pct,
            ROUND((order_value - LAG(order_value) OVER (ORDER BY month)) / 
                  NULLIF(LAG(order_value) OVER (ORDER BY month), 0) * 100, 2) AS value_change_pct,
            0 AS customer_change_pct -- Müşteri kayıt tarihi olmadığı için 0
        FROM monthly_data
        ORDER BY month DESC;

        RETURN v_cursor;
    END;
END dashboard_pkg;
/

prompt
prompt Creating trigger TRG_AUDIT_CUSTOMERS
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_customers
AFTER INSERT OR UPDATE OR DELETE ON customers
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ID=' || :NEW.customer_id || ', NAME=' || :NEW.full_name || ', EMAIL=' || :NEW.email_address;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('CUSTOMERS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ID=' || :OLD.customer_id || ', NAME=' || :OLD.full_name || ', EMAIL=' || :OLD.email_address;
    v_new_data := 'ID=' || :NEW.customer_id || ', NAME=' || :NEW.full_name || ', EMAIL=' || :NEW.email_address;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('CUSTOMERS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ID=' || :OLD.customer_id || ', NAME=' || :OLD.full_name || ', EMAIL=' || :OLD.email_address;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('CUSTOMERS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_INVENTORY
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_inventory
AFTER INSERT OR UPDATE OR DELETE ON inventory
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ID=' || :NEW.inventory_id || ', STORE=' || :NEW.store_id || ', PRODUCT=' || :NEW.product_id || ', COUNT=' || :NEW.product_inventory;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('INVENTORY', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ID=' || :OLD.inventory_id || ', COUNT=' || :OLD.product_inventory;
    v_new_data := 'ID=' || :NEW.inventory_id || ', COUNT=' || :NEW.product_inventory;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('INVENTORY', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ID=' || :OLD.inventory_id || ', PRODUCT=' || :OLD.product_id || ', STORE=' || :OLD.store_id;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('INVENTORY', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_ORDER_ITEMS
prompt ======================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_order_items
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ORDER=' || :NEW.order_id || ', PRODUCT=' || :NEW.product_id || ', QTY=' || :NEW.quantity || ', PRICE=' || :NEW.unit_price;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('ORDER_ITEMS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ORDER=' || :OLD.order_id || ', PRODUCT=' || :OLD.product_id || ', QTY=' || :OLD.quantity;
    v_new_data := 'ORDER=' || :NEW.order_id || ', PRODUCT=' || :NEW.product_id || ', QTY=' || :NEW.quantity;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('ORDER_ITEMS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ORDER=' || :OLD.order_id || ', PRODUCT=' || :OLD.product_id || ', QTY=' || :OLD.quantity;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('ORDER_ITEMS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_ORDERS
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_orders
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ORDER_ID=' || :NEW.order_id || ', CUSTOMER=' || :NEW.customer_id || ', STORE=' || :NEW.store_id || ', STATUS=' || :NEW.order_status;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('ORDERS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ORDER_ID=' || :OLD.order_id || ', STATUS=' || :OLD.order_status;
    v_new_data := 'ORDER_ID=' || :NEW.order_id || ', STATUS=' || :NEW.order_status;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('ORDERS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ORDER_ID=' || :OLD.order_id || ', CUSTOMER=' || :OLD.customer_id || ', STATUS=' || :OLD.order_status;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('ORDERS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_PRODUCTS
prompt ===================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_products
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'ID=' || :NEW.product_id || 
                  ', NAME=' || :NEW.product_name || 
                  ', PRICE=' || :NEW.unit_price ||
                  ', IMAGE=' || NVL(:NEW.image_filename, 'NULL');

    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('PRODUCTS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'ID=' || :OLD.product_id || 
                  ', NAME=' || :OLD.product_name || 
                  ', PRICE=' || :OLD.unit_price ||
                  ', IMAGE=' || NVL(:OLD.image_filename, 'NULL');

    v_new_data := 'ID=' || :NEW.product_id || 
                  ', NAME=' || :NEW.product_name || 
                  ', PRICE=' || :NEW.unit_price ||
                  ', IMAGE=' || NVL(:NEW.image_filename, 'NULL');

    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('PRODUCTS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'ID=' || :OLD.product_id || 
                  ', NAME=' || :OLD.product_name || 
                  ', PRICE=' || :OLD.unit_price ||
                  ', IMAGE=' || NVL(:OLD.image_filename, 'NULL');

    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('PRODUCTS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_SHIPMENTS
prompt ====================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_shipments
AFTER INSERT OR UPDATE OR DELETE ON shipments
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 
      'SHIPMENT_ID=' || :NEW.shipment_id ||
      ', STORE_ID=' || :NEW.store_id ||
      ', CUSTOMER_ID=' || :NEW.customer_id ||
      ', STATUS=' || :NEW.shipment_status ||
      ', ADDRESS=' || :NEW.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('SHIPMENTS', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 
      'SHIPMENT_ID=' || :OLD.shipment_id ||
      ', STORE_ID=' || :OLD.store_id ||
      ', CUSTOMER_ID=' || :OLD.customer_id ||
      ', STATUS=' || :OLD.shipment_status ||
      ', ADDRESS=' || :OLD.delivery_address;

    v_new_data := 
      'SHIPMENT_ID=' || :NEW.shipment_id ||
      ', STORE_ID=' || :NEW.store_id ||
      ', CUSTOMER_ID=' || :NEW.customer_id ||
      ', STATUS=' || :NEW.shipment_status ||
      ', ADDRESS=' || :NEW.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('SHIPMENTS', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 
      'SHIPMENT_ID=' || :OLD.shipment_id ||
      ', STORE_ID=' || :OLD.store_id ||
      ', CUSTOMER_ID=' || :OLD.customer_id ||
      ', STATUS=' || :OLD.shipment_status ||
      ', ADDRESS=' || :OLD.delivery_address;

    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('SHIPMENTS', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_AUDIT_STORES
prompt =================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_audit_stores
AFTER INSERT OR UPDATE OR DELETE ON stores
FOR EACH ROW
DECLARE
  v_old_data CLOB;
  v_new_data CLOB;
BEGIN
  IF INSERTING THEN
    v_new_data := 'STORE_ID=' || :NEW.store_id || ', NAME=' || :NEW.store_name;
    INSERT INTO audit_log(table_name, operation, changed_by, new_data)
    VALUES ('STORES', 'INSERT', USER, v_new_data);

  ELSIF UPDATING THEN
    v_old_data := 'STORE_ID=' || :OLD.store_id || ', NAME=' || :OLD.store_name;
    v_new_data := 'STORE_ID=' || :NEW.store_id || ', NAME=' || :NEW.store_name;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data, new_data)
    VALUES ('STORES', 'UPDATE', USER, v_old_data, v_new_data);

  ELSIF DELETING THEN
    v_old_data := 'STORE_ID=' || :OLD.store_id || ', NAME=' || :OLD.store_name;
    INSERT INTO audit_log(table_name, operation, changed_by, old_data)
    VALUES ('STORES', 'DELETE', USER, v_old_data);
  END IF;
END;
/

prompt
prompt Creating trigger TRG_RESTOCK_ON_CANCEL_AND_REFUND
prompt =================================================
prompt
CREATE OR REPLACE NONEDITIONABLE TRIGGER SYSTEM.trg_restock_on_cancel_and_refund
AFTER UPDATE OF order_status ON orders
FOR EACH ROW
WHEN (NEW.order_status IN( 'REFUNDED','CANCELLED'))
BEGIN
  restock_order_products(:NEW.order_id, :NEW.store_id);
END;
/


prompt Done
spool off
set define on
